date tue nov gmt server ncsa content type text html last modified thu oct gmt content length cs processes part ii deadlock cs lecture notesprocesses synchronization part ii deadlock contents terminology deadlock detection deadlock recovery deadlock prevention deadlock avoidance using processes continued deadlock terminology dining philosophers problem isn silly exercise scale model example important problem operating systems resource allocation resource defined something costs money philosophers represent processes forks represent resources three kinds resources sharable serially reusable consumable sharable resources used one process time consumable resource used one process resource gets used serially reusable resource process use resource time done give back use another process examples cpu memory interesting type resource won say kinds process requests serially reusable resource os holds done releases resource os may delay responding request resource requesting process blocked os responds sometimes say process blocked resource actual systems resources might represented semaphores monitors condition variables monitors anything process may wait resource might preemptable meaning resource borrowed process without harm sometimes resource made preemptable os cost example memory preempted process suspending process copying contents memory disk later data copied back memory process allowed continue essentially makes serially reusable resource look sharable deadlock detection formal definition deadlock set processes deadlocked process set waiting event another process set cause show deadlock graphically building waits graph draw process little circle draw arrow p q p waiting q picture called graph little circles called nodes arrows connecting called arcs find whether deadlock follows find node n arcs coming node found break erase n arcs coming nodes left deadlock algorithm simulates best case scenario every runnable process runs causes events expected process waits new events node outgoing arcs represents process isn waiting anything runnable causes events processes waiting thereby erasing incoming arcs since never wait anything cannot part deadlock erase processes left end algorithm deadlocked wait forever graph left must contain cycle path starting ending node following arcs may also contain processes part cycle waiting processes cycle processes waiting etc algorithm never erase nodes cycle since one always outgoing arc pointing next node cycle simplest cycle arc node represents process waiting usually represents simple programming bug semaphore process process deadlocked usually processes block waiting serially reusable resources events waiting release resources case put detail graph add little boxes representing resources draw arc process resource process waiting resource arc resource process process holds resource algorithm tell whether deadlock ignore algorithm page tanenbaum hard understand much less efficient one presented deadlock associated cycles cycle original graph deadlock algorithm erase everything cycle algorithm never erase part final graph contain cycles nodes paths cycles resource types often request process particular resource resource given type example process may need block memory doesn care block memory gets model assume number m resource types number e r units resource r r m general allow process request multiple resources request tell many units resource process needs continue graph gets pretty hard draw essentially algorithm used determine whether deadlock need arrays bookkeeping e r total number units resource r system c p r number units r currently allocated process p r number units r allocated process r p r number units r requested p yet allocated algorithm works simulating best case scenario add array boolean done n one element process initially set elements false find p done p r r p r r p found break r r c p r done p true p done p deadlock algorithm looks process whose request satisfied immediately finds one assumes process could given resources wants would ever wanted would eventually give back well resources previously got proved doesn matter order consider processes either succeed completing one time deadlock deadlock recovery ve discovered deadlock one thing simply re boot less drastic approach yank back resource process break cycle saw cycles deadlock resource preemptable snatching back process may irreparable harm process may necessary kill process principle least better crashing whole system sometimes better example checkpoint process time time roll back latest checkpoint hopefully time grabbed resource question database systems use checkpoints well technique called logging allowing run processes backwards undoing everything done works like time process performs action writes log record containing enough information undo action example action assign value variable log record contains previous value record database discovers deadlock picks victim rolls back rolling back processes involved deadlocks lead form starvation always choose victim avoid problem always choosing youngest process cycle rolled back enough times process grow old enough never gets chosen victim least time oldest process system deadlock recovery involves killing process altogether restarting important mark starting time reincarnated process ordinal version look older new processes started since check deadlock one best answer question depends situation eager approach check whenever something might create deadlock since process cannot create deadlock releasing resources check allocation requests os always grants requests soon possible successful request also cannot create deadlock thus check deadlock process becomes blocked made request cannot immediately granted however even may frequent deadlock detection algorithm quite expensive lot processes resources deadlock rare waste lot time checking deadlock every time request blocked cost delaying detection deadlock one possible cost poor cpu utilization extreme case processes involved deadlock cpu completely idle even processes deadlocked may blocked reasons e g waiting o thus cpu utilization drops might sign time check deadlock besides cpu isn used things might well use check deadlock hand might deadlock enough non deadlocked processes keep system busy thing look fine point view os selfish point view deadlocked processes things definitely fine processes may represent interactive users understand getting response worse still may represent time critical processes missile defense factory control hospital intensive care monitoring etc something disastrous happen deadlock detected corrected quickly thus another reason check deadlock process blocked resource request long definition long vary widely process process depends long process reasonably expect wait request urgent response overnight run deadlocks pm nobody going look output next day doesn matter whether deadlock detected pm processes system sufficiently similar may adequate simply check deadlock periodic intervals e g one every minutes batch system every millisecond real time control system deadlock prevention four necessary condition deadlock mutual exclusion resources sharable non preemption resource given process cannot revoked process voluntarily gives hold wait possible process holding resources request cycles possible cyclic pattern requests important understand four conditions necessary deadlock occur thus get rid deadlock removing one much hope getting rid condition resources inherently non sharable attacking thought weak form attack borrowing back resource another process needs use make appear two processes sharing unfortunately resources preempted acceptable cost deadlock recover discussed previous paragraph extreme form preemption attack condition either forcing process allocate resources ever need startup time making release resources allocating first approach fails process needs computing knows resources needs even practical may inefficient since process grabs resources long really needs may prevent processes proceeding second approach making process release resources allocating effect form preemption may impractical reason preemption impractical attack fourth condition practical algorithm called hierarchical allocation first algorithm project example approach resources given numbers somehow doesn matter numbers assigned processes always request resources increasing order deadlock cannot occur proof already seen cycle waits graph necessary deadlock suppose deadlock hence cycle cycle consists alternating resources processes walk around cycle following arrows see process holds resource preceding requested one following since processes required request resources increasing order means number resources must increasing go around cycle impossible number keep increasing way around cycle somewhen must drop thus contradiction either process violated rule requesting resources cycle hence deadlock precisely stated hierarchical allocation algorithm follows process requests resources requested resources must numbers strictly greater number resource currently held process algorithm work even resources given number fact given number rule reduces hold wait condition hierarchical allocation also thought relaxed form hold wait condition deadlock avoidance final approach look called deadlock avoidance approach os may delay granting resource request even resources available put system unsafe state deadlock may occur later best known deadlock avoidance algorithm called banker algorithm invented famous e w dijkstra algorithm thought yet another relaxation hold wait restriction processes allocate resources start declare upper bound amount resources need effect process gets line credit drawn needs hence name algorithm os gets request mentally grants request meaning updates data structures indicate granted request immediately let requesting process proceed first checks see whether resulting state safe undoes allocation keeps requester waiting check whether state safe assumes worst case running processes immediately request remaining resources credit lines allow checks deadlock using algorithm deadlock occurs situation state unsafe resource allocation request lead must delayed somewhat detail maintain matrix m unmet demand process p starts m p r set p credit line resource r whenever p granted resource amount deducted also deducted m new request arrives instead running deadlock algorithm simply check whether enough resources hand grant request immediately update data structures grant increase c decrease m r c requester r request r m requester r request r r request r test safety increase r matrix requests entire unmet demand m p r r p r m p r run deadlock algorithm restore r m previous values deadlock algorithm reported deadlock allow requesting process proceed request safe otherwise take back allocation add list unmet allocations instead r c requester r request r m requester r request r r request r r requester r request r solomon cs wisc edu thu oct cst copyright marvin solomon rights reserved
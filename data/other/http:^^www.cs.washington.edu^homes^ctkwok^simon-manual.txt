date tue dec gmt server ncsa content type text html last modified wed nov gmt content length simon user guide simon user guide version table contents introduction simon created release starting simon simple things try terminology simon works sal constructs miscellaneous full sal domains appendix solving universal goals known problems kludges release sal bnf partial objects sal tutorial trouble shooting tracer introduction simon softbot software robot developed university washington manual contains technical information needed use work simon simon descendent another softbot rodney shares lot functionality rodney major difference simon rodney rodney uses planner called xii determine course action whereas simon actions controlled via procedural specification expressed simon action language sal manual assumes read following sections rodney manual model manager goal language rodney action language writing operators things bear mind wherever planner would invoked rodney ie achieve goals simon invokes default mechanism outlined rest softbot architecture pretty much even though simon use xii still uses xii language specifying goals important understand syntax meaning goal language request mechanisms yet fully functional simon actions parameters sal take list valued arguments hence modifier used simon understands annotations find satisfy contemplate scope read chapters start profitably playing around simon also read following sections long model manager options shell interface planner interface functions ral commands advanced model manager sensor functions simon created softbot simon action language sal simon action language created hopes allowing easier elegant specification softbot activity sal seen search control perhaps better seen integration procedural control language simple task reduction planning sal allows intuitive procedural action design also allowing general backchaining search simon kernel close spirit raps unlike raps embrace complete ordering concern protected states explicit checks success hope design system better matches constraints opportunities software environments means taking advantage relative rarity goal clobbering simon built top ral rodney action language ral constructs supported sal details ral please refer rodney user manual release release simon considered pre alpha considered stable primary purpose release get people acquainted simon particular simon work sal syntax although hope people expand domain simon operate release robust enough someone without intermediate knowledge simon kernel include whole new domain without considerable frustration however frustrating modify existing domains three existing domains simon machine people files build upon next release robust interested building domains however ll try give much support starting simon simon compiled allegro common lisp acl suns sgis get acl simon compatible way place following line emacs file load projects ai emacs standard emacs el place following line clinit cl file load projects ai emacs standard clinit cl run emacs sun sgi machine load lisp file anything suffix cl type c c l respond prompts pressing return thus accepting defaults bit processing verify correct version lisp version loaded see acl prompt user little information navigate around emacs using acl available load simon typing user require simon may get redefinition warning messages ignore next start simon re running x windows type user ss pre defined alias start shell tracer window clim installed simon interface also steps individually similar way rodney started start shell arguments start tracer clim available system simon note shell interface meant interface shell process sun hence need make sure shells started run sun machine done either specifying host argument start shell command setting variable shell default host reasonable value follows start shell host sun host setq shell default host sun host setting variable clinit cl convenient allows use ss alias see section shell interface rodney user manual information previous step succeeded see simon prompt simon reenter simon crash quit type restart simon toplevel command rr user rr task aborted simon simple things try sal immediate descendant ral things demonstrated ral section rodney manual work simon example simon display hello world hello world works fine demo couple rodney tasks one finding office phone one finding email address via uactionwin inspecwin inspec partial object example well details please look projects softbots rodney working simon demo lisp best way learn using simon browse existing domain definitions start unix operator re familiar trace definitions see various parts implemented also see brief tutorial general process adding operator existing domain theories tracer utility handy monitoring happening covers simon quite useful debugging domains since allows one observe order goals subgoals generated worked actions used see appendix g terminology brief glossary selected terms available simon works mentioned earlier simon decomposes goals literals operates literals general scheme used literal follows predicate fact fact lookup done object cache checked possible partial object information would match literal object cache attempt address partial object problem see appendix d details model manager checked lcw presence matching literal corresponding action executed except contemplate goals find satisfy goals simon use sal actions follows presented single term goal simon map predicate action starts action example achieve find firstname p d one term goal firstname p d simon mapping done attaching action end predicate case simon solves goal calling action called firstname action dealing conjunctive goals simon processes depth first manner another example achieve find firstname p d find lastname p etzioni find office phone p num simon start attempting satisfy first literal firstname action fails point whole conjunctive goal fail suppose succeeds simon start working second conjunct conjunct cannot solved constraint placed p first conjunct simon backtrack get alternative binding first conjunct general search process continue bindings obtained satisfy three conjuncts alternatives backtracking case goal fails see one form backtracking simon allows sal try statement allows user specify explicit choice point say user specify group methods given goal may solved general template sal action tree conditions bottom try statements see examples framework allows simon efficiently handle goal level backtracking discussed example simon failed second goal conjunct want simon attempt find new binding firstname p d hasn tried yet assume three methods satisfying firstname p d bindings model action action b e b try statement possible bindings model tried simon try action ways executing action tried action b used continues satisfactory binding found alternatives tried sal constructs actions mentioned previous section simon map action goal example goal like current terminal type vt would cause following action invoked defaction current terminal type action goal type call op set term type goal invoking action first parameter action goal bound goal caused action invoked rest parameters case type bound arguments predicate vt new sal syntatic additions ral see appendix c full bnf specs call op cause operator invoked operator called simon automatically subgoals achieving preconditions call op two ways invoke operator call directly rodney example finger firstname firstname domain use call op construct example call op finger lastname lastname domain goal whereas always calls operator first case simon perform checks goal use call op second case specifically simon check model manager see lcw model manager whether goal already true model manager case simon call operator simulates xii way pruning redundant sensing addition simon check goal executes operator see goal satisfied goal satisfied call op action fail simon goal either literal variable bound goal example call op infer office phone finger rec officemate phone pt office phone officemate phone goal literal simon bind variables literal using bindings returned execution provided execution succeeds example officemate phone office phone officemate phone bound normally parameters passed operator execution e g officemate phone pt also bound notice goal satisfied calling operator operator execute thus parameters bound however variables literal still bound example means goal literal true pt wouldn bound foreach action extended allow iteration literal bindings model foreach foreach foreach examples setq x asd sdf foreach y x display y asd sdf foreach userid room u room find lastname u cs latter case simon look model manager find possible bindings u room iterate semantics literal contemplate goal simon complete example see find find new action allows conditional iteration list literal bindings similar foreach except iteration stop first binding found allows successful execution associated actions find action fails binding found find find find examples setq x asd sdf find y x display y asd displays asd display asd successful display sdf executed find userid room u room achieve find lastname u cs simon try achieve lastname u cs binding u room possible bindings already exists model manager complex example find machine netfind server machine netfind person lastname keywords machine netfind result keywords lastname userid domain progn assert person domain p domain make sure person finger lastname lastname domain fail try different netfind servers successfully find person userid sometimes netfind servers overloaded extended allow expressive conditions specify actions xii goals literals mixture literals without annotations assumed contemplate goals goal fact find goal otherwise actions successful completion means condition true examples using literal publication affiliation pub affil assert affiliation p affil publication affiliation pub affil find goal using xii goal contemplate bound domain f setq domain cs washington edu using mixture userid officemate u cs washington edu neq officemate person call op infer office phone finger rec officemate phone pt office phone officemate phone assert office phone person phone else fail first example shows using literal condition second one shows xii goal annotation contemplate false truth value third example shows combination literals xii goal action inside condition cond cond construct avoids cascades statements similar lisp counterpart also last condition specify default example defaction finger userid action goal person domain cond userid person userid call op finger userid userid domain goal lastname person last call op finger lastname last domain goal firstname person first call op finger firstname first domain goal display finger userid case attempt make sal lisp like match constant objects variables case otherwise example defaction test case x achieve contemplate annotation x ann case ann satisfy find display asd contemplate display bds otherwise display happy annotation object bound ann match annotation objects inside case statements like lisp list constants first line case statment case condition also provide default case otherwise third line example try try try action allows specifying explicit action choice point sequence actions processed one succeeds present try action always succeed otherwise fail listed actions fail provide optional goal second argument try try statements goal satisfied goal either parameter passed simon action example goal literal literal simon also try bind variables literal see call op action details simple example try works try goal b example simon try action see goal goal satisfied try action terminate successfully otherwise simon try b b also fail satisfy goal try statment still terminate successfully last action try statment fail real example try statment defaction office room action goal person room bound person try goal call op person office room person room goal lastname person lastname call op staffdir lastname goal fail fail fail fails action usually used conditionals example condition true something fail otherwise method solve goal fail progn progn groups actions like lisp progn group procedure calls firstname person firstname progn setq fi subseq firstname assert first initial person fi miscellaneous sal new objects simon uses new object type distinguish goal types e g satisfy find goals true false goals etc sal introduces new object types goal goal objects passed variables example goal parameters sal actions bound objects literals converted goals necessary annotation annotation objects representing annotations alits simon understands find satisfy contemplate scope sal new facts predicates usually used statments analyse nature goal perform appropriate actions also use obtain values well goal tv one f u goal object bool bound satisfied truth value goal matches bool bool unbound always satisfied side effect truth value goal bound bool universal satisfied var universally quantified annotation annotation bound satisfied annotation goal matches annotation annotation unbound always satisfied side effect annotation goal bound annotation supported annotations sal find satisfy contemplate scope comprehensive example defaction group protection file action goal file protection annotation goal satisfy goal tv goal f call op group unprotect file file goal call op group protect file file goal protection file file g read g write g exec full sal domains simon currently rules domains general machine files people interesting people domain examples reside projects softbots rodney working simon domains sal actions included files sal lisp suffix appendix solving universally quantified goals default simon doesn anything special universally quantified goals however case operators matching universally quantified effects would like solve goals direct application operators lcw match useful allowing us determine scope goal thus figuring operators may applicable lcw match consider example defaction person domain action goal p domain contemplate bound domain f setq domain cs washington edu hack universal p annotation goal scope lcw match p lastname p l firstname p f progn call op finger firstname f domain call op finger lastname l domain lastname p l finger lastname l domain firstname p f finger firstname f domain progn partial obj scheme slightly broken lastname p lastname bound lastname call op finger lastname lastname domain goal firstname p firstname bound firstname call op finger firstname firstname domain goal fail bound scope universally quantified variable p match statement like case statement try determine combination literals appears scope note call op would fail scope mentioned general scope operator effect appendix b kludges release known problems bugs limitations release simon may fixed next release open questions poundered upon try statments backtrack last statement action scope undeclared variables block enclosing first use unwieldy example use new variable inside progn need reference code following progn workaround assign variable outermost scope variable used perhaps setq cannot setq variable nil mm uses nil indicate bindings available conditions statments may ignored illegal dies miserably syntax error sal code also see partial objects appendix d simon solves partial object goals partially universally quantified goals working dangerous play conditional effects operators seems work checking model manager appendix c sal bnf request select achieve achieve maintain foreach foreach foreach find find find assert progn cond try try case otherwise pred call op fail assert attribute always duration duration continuous duration duration duration frequency input output appendix d partial objects time simon right thing partial objects need worry section documents simon solves partial object problem partial objects variables set constraints enough information form bind object example achieve find firstname p terrance find person domain p cs washington edu re specifying p object attributes firstname person domain know know lastname cannot completely specify person object bind p goal lookup person p firstname terrance domain cs simon solves goal caching conjuncts goals object cache required lookup facts p simon look cache obtain required information example firstname action call operator finger firstname finger firstname precondition person domain p d simon already knows person domain p cs washington edu object cache unify d cs washington edu currently simon relies xii implementation object constraints means one cannot constraint alit arguments content e defpredicate firstname person firstname first field person object second field person first name string works arguments person firstname defpredicate idle time userid machine number user active machine third parameter user idle time would never got asserted attribute cache arguments namely userid machine number one cannot constraint alit n n relationship e g defpredicate person domain person domain person domain defpredicate lastname person lastname first field person object second field person lastname defpredicate firstname person firstname first field person object second field person firstname string predicates lastname firstname would get asserted person domain defaults person n domain n f goals asserted attribute cache limitation simon cannot cache disjunctions simon ignore conditions specified dijunction cache appendix e sal tutorial typical sequence writing sal actions would starting operators operators produces effect terms start writing actions based example operator cd defoperator cd directory d path n documentation change current working directory precond find pathname d n interface exec func execute unix command translation cd n error func default unix error terminate detect read unix prompt effect cause current directory d current directory effect hence begin writing rule current directory action want see many operators produce effect get information operator producing pred machine name toplevel function opp user opp current directory pwd cd says operators pwd cd current directory effects based knowledge domain decide conditions operator would used solve current directory goal current directory action defaction current directory action goal dir annotation goal find call op pwd dir goal contemplate pathname dir n call op cd dir n goal fail basically says goal find goal use pwd find current directory otherwise cd directory none case ll fail sal actions developed incrementally current directory action solves goals may may need add additional code action support f goals initially one need focus problem one wants solved worry cases need arise fact sal actions distinguish find satisfy goals typically find variants appears appendix f trouble shooting ve tried incorporate many error catching simon m sure still lot holes simon crashes please first make sure action syntatically correct ve tried check syntax errors parser powerful enough catch problems simon crash unknown places action specification syntatically incorrect re sure fault please let ctkwok cs know bug report d helpful include actions involved action code written trace actions even stack trace zoom possible believe m trying discourage appendix g tracer acl clim one use simple browse window see simon currently tracer quite simple output log simon trying achieve simon moves along options button bring list options printing log example re interested certain options toggle ultimately set default interesting variable print enabled list interesting re interested look interface lisp customize variable clear button removes text window save button lets save trace file dialog box asks name file save file appended trace file already exists checkboxes menu bar text window shows simon status executing thinking idle note whenever new action typed simon last trace removed may want save want reference later questions comments mail cody kwok last modified tue feb pst
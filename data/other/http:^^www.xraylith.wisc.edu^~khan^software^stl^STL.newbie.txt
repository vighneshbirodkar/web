date tue nov gmt server apache content type text html content length last modified fri oct gmt mumit stl newbie guide mumit stl newbie guide document general overview special writing container objects class constructors class operators new stl containers container objects interact pointers stl gotcha storing pointers objects example pointer wrapper storing stl containers store derived objects stl container checking item map evils char phone book example new predicates comparators general functions predicates comparators general functions stl iterators iterator end return const ness iterators new using iterator tags miscellaneous examples notes copy lists right way wrong way copy maps adaptors stl stack queue etc remove vs erase list list stl sorting container sorting list user defined objects sorting vector user defined objects shuffling deck cards deducing type iterator persistent stl examples objectspace look objectspace stl toolkit template instantiation gcc new visibility template definitions manual instantiation using gcc template repository mechanism internet resources available acknowledgments document started document wastebasket random notes thoughts stl first started learning using heavily winter far included small subset stl notes file mess hopefully keep adding next weeks always welcome thoughtful comments suggestions corrections ale offers help via email khan xraylith wisc edu copyright c mumit khan back index general overview primary motivation starting guide help starting stl would like hear find useful currently document really deals issues hard find manuals create containers pointers manage manual instantiation stl template gcc etc personally use gcc combined cygnus template repository patch objectspace stl toolkit please bear mind see something doesn make sense configuration using gcc objectspace stl toolkit get touch objectspace bug fixes see info back index special writing container objects stl containers copy objects local storage typically make heavy use default constructor copy constructor assignment operator describe general guidelines read mileage may vary widely constructors operators one define working stl class constructors class x define following constructors unless re happy compiler provided ones course default constructor x copy constructor x const x stl use compiler generated one ie member wise copy embedded pointers result weird bugs see depth look needed class operators class x define following operators unless re happy compiler provided ones course operator const x better effect copy constructor operator lt const x class x essentially un ordered simply return true false example container full pointers object ordering may make sense either operator const x class x essentially un ordered simply return true false example container full pointers object ordering may make sense either operators lt important sorted collections like set map etc reason storing pointers stl sorted collections may work would expect see caveats storing pointers stl containers even though ve shown operators member functions need great since use somebody else class without modify eg library class x cannot modify define operators externally following bool operator const x x const x x bool operator const x x const x x note may need operators compilers code doesn use algorithms need operators eg sorting things compilers deal like instantiate members manually instantiate templates m luck gcc seems much better job instantiating needed members see depth look needed stl containers container objects interact one frequent questions regarding stl seems following form members define object live stl container explain without go stl source code let examine list works typical list usage scenario void f class x list x xlist populate list lots x x x xlist push back x xlist replace st element something else x x xlist front x remove element value x x x xlist remove x sort list xlist sort stuff xlist return f return let see happens steps enter new scope function f automatic objects destructed leave scope step create concrete list x parameterized type list point constructor list creates list node member data holding copy x list node looks like following template class struct list node void pointer next void pointer prev data create list node data member must default constructor equivalent constructor default arguments defined step requires default constructor add object x type x end list method push back would typically invoke following insert begin x code typical insert method iterator insert iterator position const x link type tmp get node construct value allocator address tmp data x b tmp next position node tmp prev position node prev link type position node prev next tmp position node prev tmp length return tmp step requires construction data member type x step hence requires default constructor step b uses stl allocator interface construct object argument x using placement new hence requires copy constructor typical construct looks like following template class class inline void construct p const value new p value step requires copy constructor b addition default constructor replacing first element list new object x front method returns reference lvalue data member first element list assigned new value x operation hence requires assignement operator ie operator step requires assignment operator ie operator const x x want remove element list equals value x code looks like following template class void list remove const value iterator first begin iterator last end first last iterator next first next first value erase first first next remove member starts beginning list searches till either end reached value equalling value argument found found remove removes element list calls destructor note step need equality operator operator defined work step requires equality operator ie bool operator const x x sort list sort member use place merge sort algorithm requires less relation defined object step template class void list merge list x iterator first begin iterator last end iterator first x begin iterator last x end first last first last first first iterator next first transfer first first next first next else first first last transfer last first last length x length x length template class void list sort size return list carry list counter int fill empty carry splice carry begin begin int fill counter empty counter merge carry carry swap counter carry swap counter fill fill fill merge counter fill step requires less operator ie bool operator const x x list object goes scope automatically destructed c runtime system destructor list turns calls destructor elements list hence object requires destructor step requires destructor following automatically supplied compiler defined user x default constructor constructor defined x x const copy constructor operator x const assignment operator x destructor x example contains pointers please sure define instead leaving compiler following must defined explicitly user bool operator x const equality operator bool operator x const less operator note used remove sort members smart compilers would require x define two operators special writing container objects back index pointers stl might ve noticed stl containers manage storage objects pointers caused trepidation using stl projects need store pointers various stl containers strongly suggest people revisit designs store pointers choice found far regarding stl containers pointers defined types gotcha storing pointers objects contrary believe stl care re storing pointers objects instead objects containers however often containers pointers may design flaw leads memory leaks lovely things obvious exceptions large objects expensive duplicate already constructed heap single object stored multiple containers quite common believe right way wrap pointers class manages objects perhaps via reference count need store objects derived set base objects container quite common cad systems manipulable objects derived common base set common semantics see example remember c smalltalk true heterogeneous containers simply messy c notable gotcha pointers local variables please see function change phno example manages destruction see example templatized sequence destructor stl containers use lt comparison may meaningless contexts smart pointers shine careful supplying comparator stl containers need one set map etc see rather involved example also see another example better solution wrap pointers simple class store stl containers trivial example see compilers stl implementations seem inordinate amount trouble store pointers objects instead objects stems construct destroy functions stl allocator design eg hp reference implementation comes destroy specialized pointers built types works fine store int container store x x user defined data type see benjamin scherrey note manage storing pointers stl containers example code deallocating pointers stored stl containers owns storage gotchas storing char storing pointers stl containers example code following example excerpt c l c posting subject storing object multiple container include stl h individual includes like need list h set h algo h include iostream h important see note tell set multiset map compare objects pointed rather pointers containers storing struct compare bool operator const int const int const return void print int cout int main int char list int list create list new d integers int list push back new int cout list int list begin list end print cout endl put integers set note m using custom comparator compare integers pointers set int compare set copy list begin list end insert iterator set int compare set set begin cout set int set begin set end print cout endl return run program produce following output testc list int set int special note borland c users however ben scherrey scherrey proteus tech com points os borland c compiler cannot handle believe due compiler lack support explicitly calling template destructor ben says overload destroy construct works thanks ben void destroy x pointer pointer x inline void construct x p const x value new p const x value pointers stl back index deallocating pointers stored stl containers create containers pointers make sure deallocate storage explicitly code especially container stack goes scope creating memory leak stl containers copy delete storage required hold pointer object pointing create templated deleters like following template class forwarditerator class forwarditerator void sequence delete forwarditerator first forwarditerator last first last delete first template class forwarditerator class forwarditerator void map delete forwarditerator first forwarditerator last first last delete first second map int sometype less int gt mymap populate map new d sometype map delete mymap begin mymap end objectspace uses non standard release member achieve pointers stl back index owns storage following example shows another nasty side effect storing pointers things stl containers list char means list character pointers strings point less char compare pointers strings ie use strcmp friends char buf strcpy buf would change magically list char list list push back buf ostream iterator char citer cout copy list begin list end citer see one string one buf strcpy buf yikes copy list begin list end citer surprise list changed general use char container objects rather write simple string class ask need one use instead pointers stl back index gotchas storing char example set strings cause lots headache include stl h include iostream h int main int char static char names one two three set char less char name set name set insert names name set insert names name set insert names char buf strcpy buf one const char one buf set char less char const iterator name set find one name set end cerr name one set endl else cerr found name one set endl return pointers stl back index example pointer wrapper storing stl containers store pointers stl containers especially sorted collections set map might want wrap pointers simple class works holder pointer cleans memory afterwards see example include stl h include iostream h let say want put pointers x multiple stl containers class x public x int x const x x x x x operator const x x x int operator const return private int bool operator const x x const x x return x x bool operator const x x const x x return x x define simple wrapper class put stl containers one simple wraps x class xptrwrapper public xptrwrapper x x x x xptrwrapper const xptrwrapper xw x xw x xptrwrapper xptrwrapper operator const xptrwrapper xw x xw x const x operator const return x x operator return x private x x bool operator const xptrwrapper xw const xptrwrapper xw return xw operator xw operator xw xw false bool operator const xptrwrapper xw const xptrwrapper xw return xw xw xw xw false void print const xptrwrapper xw cout xw int main int char xptrwrapper bucket int bucket xptrwrapper new x random shuffle bucket bucket list xptrwrapper list copy bucket bucket back insert iterator list xptrwrapper list cout list xptrwrapper list begin list end print cout endl put xptrwrappers set note use greater since ve defined operator set xptrwrapper greater xptrwrapper set copy list begin list end insert iterator set xptrwrapper greater xptrwrapper set set begin cout set xptrwrapper set begin set end print cout endl put integers deque deque xptrwrapper deque copy list begin list end back insert iterator deque xptrwrapper deque cout deque xptrwrapper deque begin deque end print cout endl return output list xptrwrapper set xptrwrapper deque xptrwrapper pointers stl back index store derived objects stl containers consider cad application lots objects screen derive base object would store derived objects stl container let assume derived objects set virtual functions use rtti ve done different ways store pointer container explicitly deallocate memory later course also stl implementations seem handle storage pointers uniformly would suggest using wrapper shown hard coded wrapper takes pointer base class templated pointer wrapper takes pointer base class hard coded wrapper takes pointer base class following example shows classes derived base derived derived wrapper basewrapper wrapper class assumes base class provides virtual clone facility memory management note new d base derivative passed wrapper owns deletes destructor include stl h include string h include iostream h abstract base class class base public const char typename const return typename virtual base clone const virtual void identify ostream os const virtual base public static int count protected base const char typename base const base base private char typename base base const char typename const char tname typename typename unknown strcpy typename new char strlen tname tname count base base const base base strcpy typename new char strlen base typename base typename count base base delete typename count first derived class class derived public base public derived int data base derived data data derived const derived d base derived data d data virtual derived virtual base clone const return new derived virtual void identify ostream os const int data const return data private int data virtual void derived identify ostream os const os typename data second derived class class derived public base public derived int data base derived data data derived const derived d base derived data d data virtual derived virtual base clone const return new derived virtual void identify ostream os const int data const return data private int data virtual void derived identify ostream os const os typename data define pointer wrapper class basewrapper public basewrapper base base ptr base ptr base ptr basewrapper const basewrapper bw base ptr bw bw clone basewrapper delete base ptr const base operator const return base ptr base operator return base ptr basewrapper operator const basewrapper bw delete base ptr base ptr bw clone private base base ptr bool operator const basewrapper bw const basewrapper w return false bool operator const basewrapper bw const basewrapper w return false end class defs define static members int base count int main int char list basewrapper list list push back basewrapper new derived list push back basewrapper new derived list push back basewrapper new derived list push back basewrapper new derived list push back basewrapper new derived list basewrapper const iterator list begin list end const basewrapper bw bw identify cerr cerr cerr endl endl return output derived derived derived derived derived pointers stl back index templated pointer wrapper takes pointer base class following example shows classes derived base derived derived templated wrapper wrapper wrapper class assumes base class provides virtual clone facility memory management note new d base derivative passed wrapper owns deletes destructor include stl h include string h include iostream h abstract base class class base public const char typename const return typename virtual base clone const virtual void identify ostream os const virtual base public static int count protected base const char typename base const base base private char typename base base const char typename const char tname typename typename unknown strcpy typename new char strlen tname tname count base base const base base strcpy typename new char strlen base typename base typename count base base delete typename count first derived class class derived public base public derived int data base derived data data derived const derived d base derived data d data virtual derived virtual base clone const return new derived virtual void identify ostream os const int data const return data private int data virtual void derived identify ostream os const os typename data second derived class class derived public base public derived int data base derived data data derived const derived d base derived data d data virtual derived virtual base clone const return new derived virtual void identify ostream os const int data const return data private int data virtual void derived identify ostream os const os typename data define templated pointer wrapper class must support clone method template class class ptrwrapper public ptrwrapper ptr ptr ptr ptrwrapper const ptrwrapper w ptr w w clone ptrwrapper delete ptr const operator const return ptr operator return ptr ptrwrapper operator const ptrwrapper w delete ptr ptr w clone return private ptr template class bool operator const ptrwrapper w const ptrwrapper w return false template class bool operator const ptrwrapper w const ptrwrapper w return false end class defs define static members int base count int main int char list ptrwrapper base list list push back ptrwrapper base new derived list push back ptrwrapper base new derived list push back ptrwrapper base new derived list push back ptrwrapper base new derived list push back ptrwrapper base new derived list ptrwrapper base const iterator list begin list end const ptrwrapper base w w identify cerr cerr cerr endl endl return output derived derived derived derived derived pointers stl back index checking item map bug found code back typedef map int x less int xmap xmap xmap populate xmap const x xx xmap xx map something else something else looks pretty innocuous really happens new entry xmap created gets stuffed null pointer causes amazing amount headache lines code later right way course documented fine manual following typedef map int x less int xmap xmap xmap populate xmap xmap const iterator xmap find xmap end map something else something else pointers stl back index evils char phone book example motto never use char help see following buggy example include stl h include iostream h typedef map char unsigned long less char phonebook static void print phbook ostream os const phonebook map phonebook const iterator map begin map end os first second endl static void change phno phonebook phbook const char name unsigned long phno char buf strcpy buf name phbook char buf phno int main int char phonebook phbook phbook char grumpy phbook char sleepy phbook char gandhi cerr initial phone book endl print phbook cerr phbook cerr endl change phno phbook grumpy cerr grumpy moved new number endl print phbook cerr phbook cerr endl char buf strcpy buf grumpy phbook char buf cerr grumpy moved latest number endl print phbook cerr phbook cerr endl return output might even dump core stl implementations initial phone book grumpy sleepy gandhi grumpy moved new number grumpy sleepy gandhi grumpy moved latest number grumpy sleepy gandhi grumpy hmmm two grumpy number without name pointers stl back index predicates comparators general functions stl containers algorithms make heavy use function objects either provided stl eg less user function objects typically fall different categories predicates boolean function especially useful algorithms end count find replace etc comparator boolean function useful ordered containers map priority queue etc general functions functions operate objects necessarily return value could anything predicates jim jackl mochel jimjm smtp gateway silverplatter com sent following note using find algorithm first thank maintaining useful page stl filled documentation gap twice could nt figure modena manual question cannot get handle yet search element list without passing full element example list vector regions contain pointer buffer vector region region method determining whether contains specific pointer memory bool region contains byte bfr thought able use region find list begin list end byte bfrtobesearchedfor something like stl probably limited understanding seems require use region find list begin list end regiontobesearchedfor region find list begin list end comparisonfunction neither appears answer needs suggestions would tackled please put newbie guide try posting comp lang c thank jim jackl mochel first thing note appropriate algorithm use find find also need supply predicate buffer shown right thing following solution works case class region public bool contains byte bfr const private list region regions populate regions region objects containing unique byte elements one may contain byte re looking byte bfrtobesearchedfor initialize buffer pointer find region contains given buffer pointer bufferp first let define appropriate comparator fct struct buffer byte buffer buffer const byte buffer buffer buffer bool operator const region region const return region contains buffer list region const iterator find regions begin regions end buffer bfrtobesearchedfor regions end found else found const byte bfr notice use find takes predicate supply find element comparators comparators typically used sorting ordering container objects one used sort algorithm often stl provided comparators eg less greater etc turn invoke operator sufficient cases however need supply custom comparators get job done let take following example deque int deque populate deque sort incorrect sort deque begin dequeu end code sample sort algorithm use default less int function object ordering result obviously guranteed correct two different approaches take define set comparator functions work pointers dereferencing arguments first ala objectspace stl toolkit define dereferencing function object works unary binary functions following example shows custom pointer comparator bool intp less const int const int return sort deque begin dequeu end intp less use bit structured method template class binaryfunction class binary dereference binary function binaryfunction first argument type binaryfunction second argument type binaryfunction result type public binary dereference const binaryfunction func binaryfunction func func binaryfunction result type operator binaryfunction first argument type const x binaryfunction second argument type const y const return func x y protected binaryfunction func template class binaryfunction inline binary dereference binaryfunction dereference const binaryfunction func return binary dereference binaryfunction func populate deque int deque int deque sort sort deque begin deque end binary dereference less int less int use adapter sort deque begin deque end dereference less int use set could always following typedef binary dereference less int ip compare typedef set int ip compare ip set following even structured template class binaryfunction class modifier class binary arg modifier binary function modifier argument type modifier argument type binaryfunction result type public binary arg modifier const binaryfunction func binaryfunction const modifier modifier modifier func func modifier modifier binaryfunction result type operator const modifier argument type x const modifier argument type y const return func modifier x modifier y protected binaryfunction func modifier modifier template class binaryfunction class modifier inline binary arg modifier binaryfunction modifier arg modifier const binaryfunction func const modifier modifier return binary arg modifier binaryfunction modifier func modifier template class struct dereference unary function operator const x const return x populate deque int deque int deque sort sort deque begin deque end binary arg modifier less int dereference int use adapter sort deque begin deque end arg modifier less int dereference int course use set map etc well typedef binary arg modifier less int dereference int ip compare typedef set int ip compare ip set ip set set general functions general functions useful want operate objects container sequence example using algorithm let say list appointments every day d like print ones day tentative approach class appointment public define usual members bool today date const date const private private stuff typedef list appointment appointments appointments appt book define general function void print todays appt appointment const appt appt today date print appt appt used appt book begin appt book end print todays appt another common scenario would like modify container elements within given range eg let say would like negate elements list following code shows define appropriate algorithm modify element place calling supplied function object template class outputiterator class unaryoperation void modify element outputiterator first outputiterator last unaryoperation op first last first op first first list int list populate list modify element list begin list end negate int predicates comparators general functions back index stl iterators iterator end return stl compliant container iterator end points location one beyond last item container hence invalid pointer iterator end point last item container rather points location next item would go container use push back point beyond end container point last item reason quite simple remember stl containers emulate try faithfully possible c pointer semantic end returns equivalent c pointer consider else would following end instead returned last item container mymap const iterator map find key map end key else found key bool empty const stl container container return container begin container end stl container begin returns first item container exists end otherwise stl container end returns one past end container stl iterators back index const ness iterators make sure iterators follow const ness lack thereof containers compilers utter absolutely confusing errors messages try use non const iterator const container consider following include stl h void foo const list int list list int iterator list begin list end error message gnu c g g usr local ospace usr local ospace include c const iterator cc o const iterator o const iterator cc function void foo const class list int const iterator cc matching function call list iterator int list iterator int list const iterator int usr local ospace ospace stl list h candidates list iterator int list iterator const list iterator int usr local ospace ospace stl list h list iterator int list iterator usr local ospace ospace stl list h list iterator int list iterator os list node int const iterator cc base initialization class list iterator int const iterator cc conversion list iterator int list const iterator int types default operator gmake const iterator o error course correct way use list int const iterator instead shown include stl h void foo const list int list list int const iterator list begin list end using iterator tags occasion useful dispatch based iterator type mostly due efficiency experience iterators provide mechanism called iterator category allows overload specialize based kind iterator let take stl sort algorithm example specified work containers provide random access iterators leaves list since list provides bidirectional iterators following variation sort hereby dubbed generalized sort lets sort container note use value type well slightly modified stl standard sort algorithm exclude containers support random access iterators uses interface hp reference sort first last interface code used libg stl tweaks infamous template unification failed problem version caveat emptore os stl toolkit works around gcc problem mumit khan khan xraylith wisc edu include stl h template class randomaccessiterator class inline void generalized sort randomaccessiterator first randomaccessiterator last random access iterator tag sort first last highly inefficient proves point template class bidirectionaliterator class inline void generalized sort bidirectionaliterator first bidirectionaliterator last bidirectional iterator tag deque deque copy first last back inserter deque sort deque begin deque end copy deque begin deque end first template class bidirectionaliterator inline void generalized sort bidirectionaliterator first bidirectionaliterator last generalized sort first last iterator category first value type first stl iterators back index miscellaneous examples notes copy lists right way wrong way using copy remove copy et al algorithms potentially copy one sequence another make sure target container least large resultant container likely get extra careful copying one list populated another defined unpopulated consider following list int list populate list list int list doesn work copy list begin list end list begin works back list iterator invokes push back dynamically resizes list appropriate note target set inserter would ve appropriate one copy list begin list end back list iterator int list miscellaneous examples notes back index copy maps must use insert iterator uses auxiliary iterator include stl h include math h include iostream h typedef map int float less int mymap void dump map ostream os const mymap map mymap const iterator map begin map end os first second int main int char mymap map int map sqrt mymap map map sqrt cerr map endl dump map cerr map cerr endl endl cerr map endl dump map cerr map cerr endl endl copy map begin map end insert iterator mymap map map begin cerr map map endl dump map cerr map cerr endl endl return miscellaneous examples notes back index adaptors stl stack queue etc adaptors stl fall general categories function adaptors data type adaptors function adaptors data type adaptors function adaptors study adaptors wonderful create new algorithms bind nd bind st great example create copy remove copy negating predicate supply remove copy fill list numbers const int list const int npoints sizeof list sizeof list cout endl initial list endl ostream iterator int citer cout n copy list list npoints citer create new sequence elements list note initialize result container large original one use simple output iterator cout endl removing endl list int list npoints list int iterator iter remove copy list list npoints list begin bind nd equal int copy list begin iter citer cout endl create new sequence elements list note use front insert iterator case cout endl removing endl list int list front insert iterator list int iter list iter remove copy list list npoints iter bind nd equal int copy list begin iter citer cout endl data type adaptors stack queue priority queue fall category adaptors allow use one existing container types provide certain semantics push back push front methods support specific type iterator random access iterator stacks queues example use either list deque underlying container stack queue cannot use list priority queue list support random access iterator needed priority queue use deque vector instead performance note choice list dequeu adaptor found dequeu give better cases much better performance stack queue priority queue stack use container supports push back pop back methods eg list deque vector include stl h include iostream h int main typedef stack deque int intstack intstack istack istack push istack push istack push istack push istack empty cout istack top endl istack pop return output queue use container supports push back pop front methods eg list deque include stl h include iostream h int main typedef queue deque int intqueue intqueue iqueue iqueue push iqueue push iqueue push iqueue push iqueue empty cout iqueue front endl iqueue pop return output priority queue use container supports push back pop back methods supports random access iterator eg vector deque include stl h include iostream h int main typedef priority queue deque int less int intpqueue intpqueue ipqueue ipqueue push ipqueue push ipqueue push ipqueue push ipqueue empty cout ipqueue top endl ipqueue pop return output miscellaneous examples notes back index remove vs erase using algorithms remove remove element sequential container one must also erase invalidated items container remove change size container following example shows kind surprise bring include stl h include iostream h static bool even int return int main int char list int list int list push back ostream iterator int cout cout initial list x copy list begin list end cout endl list int iterator end remove list begin list end even cout removing even numbers surprise copy list begin list end cout endl list erase end list end cout erasing removed numbers copy list begin list end cout endl return output initial list x removing even numbers surprise erasing removed numbers miscellaneous examples notes back index list list stl post c l c inquiring iterate members list members also lists following code snippet shows nothing special list lists sample stl program show iterate thru list list include stl h include iostream h convenience typedefs save typing typedef list int list typedef list list listoflist void print list const list list int id ostream iterator int cout cout list id copy list begin list end cout endl int main listoflist list list create list list total lists members int list list int j j j list push back j print list list list list push back list cout endl iterator thru list lists listoflist iterator list list begin int j list list end j const list list print list list j return output list list list list list list miscellaneous examples notes back index sorting stl container stl provides sort algorithm sort container support random access iterators vector deque containers support random access iterators list stl containers typically sort member function job d rather single sort algorithm job regardless iterator type see example things look containers support random access iterators use stl sort algorithm uses quicksort container objects non trivial arm container object appropriate constructors comparison operators see info sorting list user defined objects sorting vector user defined objects sorting list user defined objects include iostream h include stdlib h include stl h include string h inline char strnew const char str char newstr str newstr new char strlen str strcpy newstr str return newstr struct listelem int id char name listelem id name strnew unknown listelem const listelem elem id elem id name strnew elem name listelem int id const char name id id name strnew name listelem delete name listelem operator const listelem elem id elem id delete name name strnew elem name bool operator const listelem elem const return id elem id bool operator const listelem elem const return id elem id void print ostream os const os id name void print list ostream os const list listelem list list listelem const iterator list begin list end const listelem elem elem print os int main int char list listelem list list push back listelem strnew list push back listelem strnew list push back listelem strnew list push back listelem strnew list push back listelem strnew cerr initial list print list cerr list cerr endl cannot use sort list begin list end instead must use sort member list class hint lists support random access iterators list sort cerr sorted list print list cerr list cerr endl return output stl list sort initial list sorted list sorting stl container back index sorting vector user defined objects include iostream h include stdlib h include stl h include string h inline char strnew const char str char newstr str newstr new char strlen str strcpy newstr str return newstr struct listelem int id char name listelem id name strnew unknown listelem const listelem elem id elem id name strnew elem name listelem int id const char name id id name strnew name listelem delete name listelem operator const listelem elem id elem id delete name name strnew elem name bool operator const listelem elem const return id elem id bool operator const listelem elem const return id elem id void print ostream os const os id name void print vector ostream os const vector listelem vector vector listelem const iterator vector begin vector end const listelem elem elem print os int main int char vector listelem vector vector push back listelem strnew vector push back listelem strnew vector push back listelem strnew vector push back listelem strnew vector push back listelem strnew cerr initial vector print vector cerr vector cerr endl sort vector begin vector end cerr sorted vector print vector cerr vector cerr endl return output stl list sort initial list sorted list sorting stl container back index shuffling deck cards someone asked shuffle deck cards c l c rec games bridge days lots correct long answers using sorts tricks avoid duplicate numbers random sequence produced simple one using stl random shuffle right however look random shuffle especially iter swap make sure seed dynamically chosen eg use current clock value instead hard coded seed value used stl implementations include stl h individual includes like include iostream h int main int char const unsigned ncards int cards ncards int ncards cards print initial list ncards ostream iterator int cout cout initial copy cards cards ncards cout endl shuffle print shuffled list random shuffle cards cards ncards cout shuffled copy cards cards ncards cout endl return output initial shuffled miscellaneous examples notes back index deducing type iterator sometimes useful able deduce type container element given iterator container question global function value type purpose following code snippet shows usage template class inputiterator class void something inputiterator first inputiterator last tmp create variables type template class inputiterator void something inputiterator first inputiterator last something first last value type first miscellaneous examples notes back index persistent stl m making available extremely simple crude implementation persistent stl using libg hacked stl base implementation send email d like know current prototype based texas persistent store v ut austin oops research group click gnu zip d tar d copy current prototype v persistent stl back index look objectspace stl toolkit slightly modified excerpt one postings c l c ve using objectspace stl toolkit gcc quite heavily last weeks turns pretty solid obviously get gcc supports objectspace pretty good job squeezing everything possible gcc implementation ve run problems well known ones mentioned release notes easy work arounds recently switched objectspace stl toolkit gcc gcc users objectspace providing bug fixes stl toolkit version make work gcc please get touch objectspace tehnical support information acquire fixes re using gcc two things start patch template fix ftp ftp cygnus com pub g gcc template fix solves multiple definition problem learn art manual template instantiation want avoid incredible code bloat reasonable sized programs re using gcc two things start patch template repository fix ftp ftp cygnus com pub g gcc repo gz allows use template repositories instantiate templates learn instantiate templates using cygnus frepo things favor objectspace implementation great install utility esp want use multiple compilers tons example programs believe donated public domain archived hp stl site butler hpl hp com terrific manual manual worth pay os stl source code guess ll kind hard supply source good greatest telephone support crippled limitations gcc make lot easier least used member instantiation one side effect extra unnecessary code generated one even use sort list still define relation operator manual instantiation uniform across platforms utah hp pa gcc release needs extra instantiations non standard methods like erase non standard algorithms like release documentation mention non standard index note well trivial write make sure code works implementations good bad os provides stl h includes everything personally liked started recommend newcomers figure stl pretty easy include necessary include files obvious compile time tradeoff may available implementations eg ones hp fsf gnu trivial write see example one header file names may different implementations example os algorith h vs fsf gnu hp algo h choose include individual headers instead stl h shabang watch tiny things need portability implementations overall definitely worth money back index template instantiation gcc templated code eg using stl re stuck gcc three somewhat portable ways go like weird pragma directives compiler specific compile everything special flags let gcc instantiate everything sight statically translation unit great re building small applications single source file results incredible code bloat medium large applications compile everything fno implicit templates manually instantiate templates takes bit patience c demangler c filt certainly doable alleviate template bloat somewhat see info re willing upgrade gcc version apply frepo patch jason merrill cygnus support pleasantly surprised easy template instantiation see info upgraded gcc using first method starting new project migrate second one repository mechanism hardly ever manual instantiation visibility template definitions one major complication gcc template definitions must visible point instantiation may case borland wouldn know template class members defined cc file included declaration file h ll get undefined errors simple trick conditionally include cc file template header h file preprocessor directive gets set compilers like gcc take following example template h template class class xx public xx value const declaration defn inline private template cc include template h template class xx value const return main cc include iostream h include template h int main int char xx int xx cerr value xx value endl return work gcc unless also include template cc end template h ll get undefined error looks something like ld undefined symbol xx int value void const collect ld returned exit status get around always following template h template class class xx public xx value const private include template definition include template cc endif somewhere else config h via makefile define cpp symbol include template definition using gcc something like following work well gnuc gnuc minor define include template definition endif gcc able need since see definition tries instantiate xx int main cc visibility template definitions back index manual instantiation templates gcc let start trivial program list stl data type used specifically list int examples m assuming objectspace stl toolkit gcc appropriately patched jason merrill template fix idea applies fsf gnu stl particular set templates need instantiated may differ due implementation differences trivial test program include stl h include everything simplicity include iostream h include stdlib h int main int char list int list int list push back rand return running following compile link commands stl include dirs stl libs depend system g fno implicit templates c stl include dirs f cc g o f f o stl libs c filt ld undefined symbol list int list void list int push back int const list int list void collect ld returned exit status gmake f error instantiate members list int listed problem gcc doesn allow instantiating individual members ll simply instantiate members gcc fixes create file template inst cc include stl h template class list int compile w fno implicit templates option link f o re business g c stl include dirs template inst c g o f f o template inst o stl libs c filt f note using fno implicit templates manual instantiation file get lots trouble try see something static indirect template functions get instantiated indirectly using fno implicit templates flag bit reality let say going use following templated data types stl list int deque int following algorithms copy ostream iterator copy list deque list objects include stl h include everything simplicity include iostream h include stdlib h int main int char deque int deque int deque push back rand ostream iterator int cout cout deque copy deque begin deque end cout endl endl list int list copy deque begin deque end back insert iterator list int list cout list copy list begin list end cout endl endl nested within main struct going cause problems later struct foobar void operator int val const cout val cout list list begin list end foobar cout endl endl return g fno implicit templates c stl include dirs f cc g o f f o stl libs c filt ld undefined symbol list int list void deque int deque void deque int begin void copy list iterator int list iterator int ostream iterator int copy deque iterator int deque iterator int ostream iterator int copy deque iterator int deque iterator int back insert iterator list int ostream iterator int ostream iterator ostream char deque int end void list iterator int list iterator int main foobar list int list void list int begin void list int end void back insert iterator list int back insert iterator list int deque int deque void deque int push back int const collect ld returned exit status gmake f error note instantiation cannot manually instantiate main foobar simply move foobar file scope shown redo compile link commands moving foobar file scope f cc g fno implicit templates c stl include dirs f cc g o f f o stl libs c filt ld undefined symbol list int list void deque int deque void deque int begin void copy list iterator int list iterator int ostream iterator int copy deque iterator int deque iterator int ostream iterator int copy deque iterator int deque iterator int back insert iterator list int ostream iterator int ostream iterator ostream char deque int end void list iterator int list iterator int foobar list int list void list int begin void list int end void back insert iterator list int back insert iterator list int deque int deque void deque int push back int const collect ld returned exit status gmake f error create template inst cc file include stl h include iostream h template class list int template class list iterator int template class back insert iterator list int template class ostream iterator int template class deque int template class deque iterator int template void copy list iterator int list iterator int ostream iterator int template void copy deque iterator int deque iterator int ostream iterator int template void copy deque iterator int deque iterator int back insert iterator list int struct foobar void operator int val const cout val template void list iterator int list iterator int foobar g fno implicit templates c stl include dirs f cc g c stl include dirs template inst cc g o f f o template inst o stl libs c filt f deque list list manual instantiation templates gcc back index using gcc template repository mechanism let start trivial program list stl data type used specifically list int examples m assuming objectspace stl toolkit gcc appropriately patched jason merrill template frepo patch also work fine stl implementation happens work gcc trivial example building simple standalone application providing library closure trivial example building simple standalone application trivial test program include stl h include everything simplicity include iostream h include stdlib h int main int char list int list int list push back rand return running following compile link commands stl include dirs stl libs depend system g frepo c stl include dirs f cc g frepo o f f o stl libs collect recompiling f cc collect relinking collect recompiling f cc collect relinking collect recompiling f cc collect relinking voila granted first time better go lunch build subsequent times much faster work quick answer look build directory f rpo study get good feel happenning following start afresh ie delete f f o f rpo simply compile f cc frepo option copy rename resulting f rpo file another file say f rpo org build executable f example compare updated f rpo saved version notice difference first column o c d like longer explanation read source code providing library closure let say re building library n c source files would like provide template closure clients worry instantiating templates used library code simplest method following build object files needed build library using frepo option gcc cppflags cxxflags frepo o closure objs collect recompiling xx cc collect relinking collect recompiling xx cc collect relinking whole bunch error messages unresolved stuff ignore ar crv libxyz objs ranlib libxyz link step forces instantiation templates used within library rebuilds o files clients provide instantiation templates library directly use thanks jason merrill info forced instantiation fortunately quite extendible consider following case application needs link libraries l l library l uses l hence templates l also instantiated l build separately using method described previous paragraph fix quite simple build l example case ie force instantiation templates used within build l l command line gcc cppflags cxxflags frepo o closure l objs libl collect recompiling xx cc collect relinking collect recompiling xx cc collect relinking whole bunch error messages unresolved stuff ignore ar crv libl l objs ranlib libl link application two libraries re business using gcc template repository mechanism back index example combined stl h file suck entire hp implementation derived stl helpful beginners one gets familiar stl easy figure headers include also different implementations might different header names eg objectspace algorith h hp algo h go figure ifndef stl h define stl h include algo h include function h include iterator h include list h include deque h include map h include pair h include set h include stack h include vector h endif back index internet resources available free stl implementations hp supposedly compiles borland c box alternate site fsf gnu libg works gcc newer based carsten bormann work fsf gnu libg works gcc newer based carsten bormann work bagnara another hacked stl based hp implementation modified gnu sources works gcc newer c draft standard document html version dwp courtesy mike stump cygnus support pdf postscript versions bell labs ftp site web pages ftp sites info stl objectspace examples objectspace contributed examples public domain good start beginners joseph y laurino stl page musser stl docs examples nice stl newbie home site marian corcoran stl faq jak kirman stl tutorial back index acknowledgments thanks kate hedstrom adam back providing much motivation turning article html grateful jason merrill mike stump cygnus support informative posts comp lang c especially answering questions use frepo switch gcc c code fragments converted html using c html written dimitry kloper dimka tochna technion ac il stl examples contributed objectspace found back index c class libraries back mumit home page gnu zipped tar copy files click warning usually never quite date view changelog mumit khan khan xraylith wisc edu last change oct
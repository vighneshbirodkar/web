date tue nov gmt server ncsa content type text html last modified wed aug gmt content length lecture notes chapter data representation chapter representations integer representation computers operate binary values result built transistors different binary representations integers possible qualifications positive numbers positive negative numbers ease human readability speed computer operations commonly known common integer reprentations used various times various reasons unsigned sign magnitude one complement two complement biased commonly known virtually modern computers operate based complement representation hardware faster hardware simpler unsigned standard binary encoding already given positive values range n n bits example bits values n binary decimal hex binary decimal hex b c d e f sign magnitude human readable way getting positive negative integers hw arithmetic sign magnitude integers fast complex hw arithmetic comp comp integers use bit integer represent sign integer let sign bit positive negative rest integer magnitude uses encoding unsigned integers example bits get additive inverse number flip invert complement negate sign bit range n n n number bits bits n sign bit representations problem hardware computer must calculations come correctly whichever representation used one complement historically important use representation get complement integers nobody builds machines based comp integers past early computers built semour cray cdc based comp integers positive integers use representation unsigned etc negation finding additive inverse done taking bitwise complement positive representation complement invert flip negate logical operation done single bit complement complement take complement bit add take away bits examples must negative number find find additive inverse sight must things notice negative number msb representations two complement variation complement representations makes hardware arithmetic faster representations bit example bit pattern comp comp negative values slid one eliminating extra zero representation get integer comp representation positive values sign mag comp msb sign bit positive write value negative take positive value take comp comp add comp get additive inverse comp integer take comp add add without really knowing add start lsb bit working right left bit change encountered change stop example decimal value two complement represent must negative number since significant bit therefore find additive inverse comp taking complement comp therefore additive inverse must little bit adding ll see really next chapter brief overview carry b sum carry b sum really like decimal binary sum carry sum carry biased representation integer representation skews bit patterns look like unsigned actually represent negative numbers examples given bits bias values true value represented add bias unsigned value bit pattern biased representation going way suppose given biased representation unsigned represents subtract bias true value represented representation allows operations biased numbers unsigned integers actually represents positive negative values choosing bias bias chosen often based number bits available representing integer get approx equal distribution true values bias n n sign extension change integer smaller number bits integer representation larger number bits must done lot arithmetic units best go representation unsigned xxxxx xxxxx copy original integer lsbs put elsewhere sign magnitude sxxxx xxxx copy original integer magnitude lsbs put original sign msb put elsewhere complement called sign extension copy original integer lsbs take msb original integer copy elsewhere example overflow sometimes value cannot represented limited number bits allowed examples unsigned bits would require least bits sign mag bits would require least bits value cannot represented number bits allowed say overflow occurred overflow occurs arithmetic operations example bit unsigned representation would require bits represent value unsigned rep character representation everything represented computer represented binary sequences common non integer needed represented characters use standard encodings binary sequences repreesent characters rememeber bit patterns imply representation o devices work bit quantities standard code ascii american standard computer information interchange defines character represented sequence examples hex decimal represents hex decimal represents b different bit patterns used different character needs represented code nice properties bit patterns compared pretending represent integers integer steps read translate read translate integer read translate integer algorithm integer characters get character digit character string steps figure many characters div gives translate print mod gives div gives translate print mod gives div gives translate print mod gives re done representation floating point numbers computers represent real values form similar scientific notation standards define representation means across computers consistancy note way represent floating point numbers ieee standard way representation e f one bit representing sign number e bit biased integer representing exponent f unsigned integer true value represented e x f x e e bias n f f single precision numbers emphasis class n bias mean e f represent fields within representation bunch bits sign bit positive negative e exponent field e field biased representation true exponent represented e bias radix number always note computers use representation like built standard always use radix example ibm machines radix f mantissa somewhat modified form bits available mantissa turns fl pt numbers always stored normal form leading bit one left msb always store gets put back number giving bits precision mantissa calculation store bits msb called hidden bit example put decimal number standard single precision representation first step get binary representation get binary reps stuff left right decimal point separately gotten using algorithm x x x x x whole pattern repeats x x x binary representation putting halves back together second step normalize binary representation make look like scientific notation x third step true exponent standard form needs biased form bit unsigned representation bit pattern used e standard form fourth step mantissa stored f stuff right radix point normal form need bits put together include correct sign bit e f values often given hex x extra details since floating point numbers always stored normal form represent fl pt number x f represent take bit patterns x x represent value fl pt numbers cannot represented special values infinity x f infinity xff nan number either e xff f anything zeros
date mon nov gmt server ncsa content type text html last modified fri aug gmt content length debug gcl debug gcl several debugging facilities gcl common lisp loading syntax checking step function interactive break package trace function tutorial simple piece buggy lisp code used show use debugging facilities assume file named buggy lisp following function definitions file buggy lisp begins separate takes list containing level symbols numbers returns list form numbers list symbols list defun separate alist cond endp alist nil endp first alist separate rest alist numberp first alist cons first alist separate rest alist symbol first alist append separate rest alist list first alist merge separate first alist separate rest alist defun merge list list let result list dolist anitom list result cond numberp anitom setq result cons anitom result symbolp anitom setq result append result list anitom file buggy lisp ends try load code load buggy lisp get error unexpected end fast links use fast links nil debugging error signaled load broken load type h help means file load detect extra ignores extra may cause problems later execution fix insert one print statement defun block find defun block extra use vi commands defun block match find need end separate function corrected separate function defun separate alist cond endp alist nil numberp first alist cons first alist separate rest alist symbolp first alist append separate rest alist list first alist merge separate first alist separate rest alist error corrected run load buggy lisp get following message loading buggy lisp warning merge redefined finished loading buggy lisp warning means gcl already function named merge definition higher priority used run separate b get error function symbol undefined fast links use fast links nil debugging error signaled cond broken cond type h help break package invoked automatically enter break command h get list break commands example m prints last break message function symbol undefined know error related symbol b prints full backtrace functions backtrace system top level eval separate cond know error occurs look symbol cond statement inside separate function find use symbolp instead symbol type checking defun separate alist cond endp alist nil numberp first alist cons first alist separate rest alist symbolp first alist error corrected append separate rest alist list first alist merge separate first alist separate rest alist run separate b get error symbolp anitom invalid function fast links use fast links nil debugging error signaled dolist broken dolist type h help use m b break commands m symbolp anitom invalid function problem gcl tries interpret result returned symbolp anitom function b backtrace system top level eval separate cond append separate cond merge separate cond merge let dolist problem happens several recursive calls separate dolist statement merge function originally intend symbolp anitom case cond statement seems cond finishes correctly program returns cond breaks dolist implies cond ended early extra symbolp anitom left cond treated gcl function check cond statement find extra case symbolp anitom fix deleting adding another end symbolp anitom case include cond statement defun merge list list let result list dolist anitom list result cond numberp anitom setq result cons anitom result error corrected symbolp anitom setq result append result list anitom error corrected run separate b get although get break error message result expect use trace trace merge separate see working correctly trace merge warning merge redefined merge btw always turn trace merge untrace merge command separate b separate b merge b call b return b merge nil nil merge nil find merge working expected example merge b return b instead decide turn trace use step look simple case closely untrace merge step merge b type newline help merge b let result list nil steps find problem tried initialize result list turns nil could happen look let statement find let result list initialize result list let result list treat result list new local variables initialize nil fix run merge b separate b time almost working way want merge b b separate b nil b yet nil accumulated exclude specific case result adding one case cond statement separate function defun separate alist cond endp alist nil null first alist separate rest alist error corrected numberp first alist cons first alist separate rest alist symbolp first alist append separate rest alist list first alist merge separate first alist separate rest alist ready turn relax
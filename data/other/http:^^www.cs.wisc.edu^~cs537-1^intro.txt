date tue nov gmt server ncsa content type text html last modified thu oct gmt content length cs introduction cs lecture notesintroduction contents history os bottom view top view course outline history computers expensive rare cheap expensive ubiquitous hardware trends vacuum tubes core memory punched cards transistors magnetic tapes integrated circuits disks vlsi computer chip main frame million mini k m workstation k k micro pc k k network computer software batch system one user time person programmer operator end user wants something done multiprogrammed one job time improve utilization e g spooling time sharing multiple interactive users single user pc ws come full circle kinds systems transaction processing e g banking airlines real time e g missile defense factory control embedded systems computer every toaster os beautification principle goal os make hardware look better regular uniform instead lots idiosyncratic devices easier program e g worry speeds asynchronous events closer needed applications named variable length files rather disk blocks multiple cpu one user shared system activity single user system multiple large dynamically growing memories virtual memory resource principle goal os mediate sharing scarce resources q resource something costs money share expensive devices need share data database expensive device cooperation people community expensive device problems getting work getting work efficiently utilization keeping devices busy throughput getting lot useful work done per hour response getting individual things done quickly protection limiting effects bugs preventing idiots ruining everyone preventing unauthorized access data modification data use resources preventing bad guys ruining everyone bottom view starting hardware hardware summary details later components one central processing units cpu main memory ram core o devices bus communication mechanism connects together cpu pc pointing next instruction execute fetches instructions one time location specified pc increments pc fetching instruction branch instructions also alter pc responds interrupts jumping different location like unscheduled procedure call memory responds load store requests cpu one time o device usually looks like chunk memory cpu cpu sets options starts o sending store requests particular address cpu gets back status small amounts data issuing load requests direct memory access dma device may transfer large amounts data directly memory loads stores like cpu issues interrupt cpu indicate done timing problem o devices millions even billions times slower cpu e g typical pc million instructions sec typical disk takes ms get one byte disk ratio typical typist wpm word bytes sec ms million instructions per key stroke doesn include head scratching time solution start disk device instructions useful computation wait disk finish terrible program write debug would change faster disk better solution process start o wait finish use data something process useful computation operating system takes care switching back forth process process appropriate question process higher priority space problem time typical program wasting memory space allocated looping one subroutine wasting space allocated rest program fiddling one data structure wasting space allocated data structures waiting o user input wasting space solution virtual memory keep program data disk times cheaper byte os automatically copies memory pieces needed program demand top view look like various kinds users end user wants get something done bill customers write love letter play game design bomb doesn know os care may even realize computer application programmer writes software end users uses beautified virtual machine named files unlimited size unlimited memory read write returns immediately calls library routines really subroutines written someone else sort array solve differential equation search string character others call operating system read write create process get memory systems programmer end course creates abstractions application programmers deals real devices course outline processes processes using processes synchronization communication semaphores critical regions monitors conditions messages pipes process structures pipelines producer consumer remote procedure call deadlock implementing processes mechanism critical sections process control block process swap semaphores monitors policy short term scheduling fcfs round robin shortest job next multilevel queues memory main memory allocation swapping overlays stack allocation implementation programming languages virtual memory hardware paging segmentation translation lookaside buffer policy page replacement algorithms random fifo lru clock working set o devices device drivers interrupt handlers disks hardware characteristics disk scheduling elevator algorithm file systems file naming file structure user view flat array bytes record structured indexed random access metadata mapped files implementation structure linked tree structured b tree inodes directories free space management protection security threats access policy capabilities access control lists implementation authentication determination enforcement encryption conventional public key digital signatures solomon cs wisc edu thu oct cst copyright marvin solomon rights reserved
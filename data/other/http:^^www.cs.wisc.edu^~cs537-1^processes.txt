date tue nov gmt server ncsa content type text html last modified thu oct gmt content length cs processes cs lecture notesprocesses synchronization contents using processes process use processes creating processes process states synchronization race conditions semaphores bounded buffer problem dining philosophers monitors messages tanenbaum mixes presentation features processes interest programmers creating concurrent programs discussion techniques implementing result least confusing attempt first present processes associated features user point view little concern possible questions implemented turn question implementing processes using processes process process little bug crawls around program executing instructions sees normally called sequential programs exactly one process per program concurrent programs may several processes executing program details constitutes process differ system system main difference amount private state associated process process program counter register tells program also needs place store return address calls subroutine two processes executing subroutine called different places return correct calling points since subroutines call subroutines process needs stack return addresses processes little private memory called threads light weight processes minimum thread needs program counter place store stack return addreses values could stored memory shared threads extreme process could private memory space sharing read program text processes essentially way unix process works points along spectrum possible one common approach put local variables procedures private stack return addresses let global variables shared processes stack frame holds local variables procedure together indication return procedure returns indication calling procedure stack frame stored java follows approach global variables threads share heap heap region memory used allocate objects response new short variables declared procedures local threads objects shared course thread see object reach object base object one containing run method one local variables class foo implements runnable object obj obj foo object obj public void run object obj new object obj new object int something class bar static public void main string args object obj new object runnable foo new foo obj thread new thread foo runnable foo new foo obj thread new thread foo start start something three treads program main thread two child threads created child thread stack frame foo run space obj thus two copies variable obj points different instance object objects shared heap since one thread way getting object created thread objects effectively private similary objects pointed obj effectively private copies obj copy obj main thread point shared object names sometimes used processes job task possible combine threads processes system example run java unix java program run separate unix process unix processes share little java threads one unix process share everything private stacks use processes processes basically programming convenience settings great convenience would nearly impossible write program without process allows write single thread code get task done without worrying possibilty may wait something happen along way examples server providing services others one thread client timesharing system one thread logged user real time control computer controlling factory one thread device needs monitoring networking one thread connection creating processes new process created needs know start executing java thread given object created started starts execution beginning run method object unix new process started fork command starts execution statement immediately following fork call call parent process called fork child executing point program child given memory space initialized exactly copy memory space globals stack heap objects parent thus child looks like exact clone parent indeed hard tell apart difference fork returns child non zero value parent char str main int j str main program j f cout str j endl void f int k k fork k str child value return else str parent value return program starts one process executing main process calls f inside f calls fork two processes appear return fork parent child process copy global global variable str copy stack contains frame main variable j frame f variable k return fork parent sets copy k non zero value child sets copy k zero process assigns different string copy global str returns different value assigned process copy j two lines printed parent value child value actually lines might intermingled process states process started either runnable blocked become blocked something explicitly blocks wait something implicitly block read request systems also possible one process block anther e g thread suspend java runnable process either ready running many running processes cpus one responsibilities operating system called short term scheduling switch processes ready running state synchronization race conditions consider following extremely simple procedure void deposit int amount balance amount assume balance shared variable two processes try call deposit concurrently something bad happen single statment balance amount really implmented computers buy sequence instructions load reg balance add reg amount store reg balance suppose process p calls deposit process p calls deposit one completes starts combined effect add balance desired however suppose calls happen exactly time executions interleaved suppose initial balance two processes run different cpus one possible result p loads register p loads register p adds register giving p adds register giving p stores balance p stores balance net effect add tot balance kind bug occurs certain timing conditions called race condition extremely difficult kind bug track since may disappear try debug may nearly impossible detect testing since may occur extremely rarely way deal race conditions careful coding avoid kinds problems systems support processes always contain constructs called synchronization primatives semaphores one earliest simplest synchronization primitives semaphore consider later semaphores implemented treat like java object hides integer value allows three operations initialization specified value increment decrement class semaphore private int value public semaphore int v value v public void public void operation read current value two bits magic make seemingly useless class extremely useful value never permitted negative value zero process calls process forced wait goes blocked state process calls semaphore operations atomic correct implementation must make appear occur instantaneously words two operations semaphore attempted time must interleaved case operation blocks caller actual decermenting must atomic ok things happen calling process blocked first example uses semaphores fix deposit function shared semaphore mutex new semaphore void deposit int amount mutex balance amount mutex assume one semaphore call mutex mutual exclusion shared processes keyword shared java omitted clear variables shared private separate copy process semaphores useless unless shared omit shared semaphore also abreviate declaration initialization semaphore mutex let see works one process wants make deposit mutex decreasing value mutex zero adds amount balance returns value mutex one two processes try call deposit time one get operation first atomic find mutex already zero forced wait first process finishes adding balance mutex returning value one allowing process complete operation three processes trying time one would first two would forced wait first process one two would allowed complete operation mutex would zero third process would continue wait bounded buffer problem suppose producer consumer processes may many producers somehow produce objects consumers use something one buffer object used pass objects producers consumers show implementation buffer easy exercise buffer hold n objects problem allow concurrent access buffer producers consumers ensuring shared buffer data structure screwed race conditions accessing consumers try remove objects buffer empty producers try add objects buffer full condition dropped buffer assumed infinite capacity problem called producer consumer problem tanenbaum calls bounded buffer problem producer consumer problem solution shared buffer b semaphore mutex empty n full class producer implements runnable public void run object item item produce empty mutex b enter item item mutex full class consumer implements runnable public void run object item full mutex item b remove item mutex empty surround operations shared buffer data structure mutex mutex prevent interleaved changes two processes may screw data structure semaphore full counts number objectx buffer semphore empty counts number free slots operation full consumer atomically waits something buffer lays claim decrementing semaphore suppose replaced b count nothing mutex would possible one process see buffer non empty another process remove last item got chance grab mutex semapore one fine point notice suppose revesed operations consumer mutex full consumer tries operation buffer empty first grabs mutex semaphore blocks full semaphore blocked forever process grab mutex semaphore add item buffer thus call full situation called deadlock study length later dining philosophers five philosopher processes numbered pair philosophers fork forks also numbered fork philosophers arithmetic fork numbers philosopher numbers modulo fork philosophers philosopher alternates thinking eating eat needs exclusive access forks size class philosopher implements runnable int philosopher public void run think take forks eat put forks first attempt solve problem represents fork semaphore semaphore fork void take forks int fork fork void put forks int fork fork problem solution lead deadlock philosopher picks right fork tried pick left fork happends timing works philosophers get hungry time pick right forks gets chance try left fork philosopher holding fork waiting fork wait forever simple solution instead trying right fork first try lower numbered fork first show later solution cannot lead deadlock implementing generalization technique project solution deadlock free still good could consider situation philosophers get hungry time pick lower numbered fork philosopher philosopher try grab fork first suppose philosopher wins since philosopher stuck waiting fork philosopher able grab forks start eating philosopher gets eat philosophers waiting even though neither shares fork philosopher hence one could eat right away dijkstra suggests better solution shows derive solution thinking two goals synchronization problem safety make sure nothing bad happens liveness make sure much good happens consistent safety criterion philosopher let state state philosopher one thinking hungry eating safety requirement adjacent philosophers simultaneously eating liveness criterion philosopher hungry unless one neighbors eating hungry philosopher start eating unless saftey criterion prevents formally safety state eating state eating liveness state hungry state eating state eating observation solution almost writes see also figure page tanenbaum semaphore mayeat semaphore mutex int state thinking thinking thinking thinking thinking void take forks int mutex state hungry test mutex mayeat void put forks int mutex state thinking test test mutex void test state hungry state eating state eating state eating mayeat method test checks violation liveness position violation occur philosopher gets hungry one neighbors finishes eating monitors although semaphores need solve lots synchronization problems rather low level error prone saw slight error placement semaphores switching order two operations bounded buffer problem lead big problems also easy forget protect shared variables bank balance buffer object mutex semaphore better higher level solution provided monitor also invented dijkstra look example uses semaphores see used two rather different ways one simple mutual exclusion semephore always called mutex examples associated shared variable variables piece code touches variables preceded mutex followed mutex since hard programmer remember easy compiler let compiler work monitor class bankaccount private int balance public void deposit int amount balance amount etc keyword monitor tells compiler add field semaphore mutex class add call mutex beginning method put call mutex return point method way semaphores used block process cannot proceed another process something example consumer discovering buffer empty wait producer philosopher getting hungry may wait neighbor finish eating provide facility monitors special kind variable called condition variable class condition public void signal public void wait condition variable like semaphore two differences semaphore counts number excess operations signal operation condition variable effect unless process waiting wait condition variable always blocks calling process wait condition variable atomically monitor mutex blocks caller words c condition variable c wait rather like mutex c except operations done together single atomic action solution bounded buffer problem using monitors monitor boundedbuffer buffer b condition nonfull nonempty public void enter item object item b isfull nonfull wait b enter item item nonempty signal public object remove item b isempty nonempty wait item result b remove item nonfull signal return result general condition variable associated logical condition state monitor expression may either true false process discovers part way method logical condition needs satisfied waits corresponding condition variable whenever process makes one condtions true signals corresponding condition variable waiter wakes knows problem caused go sleep fixed may immediately proceed kind reasoning valid important nobody else sneak time signaller signal waiter wakes thus calling signal blocks signaller yet another queue immediately wakes waiter multiple processes blocked condition variable one waiting longest wakes process leaves monitor returns one methods sleeping signaller allowed continue otherwise monitor mutex released allowing new process enter monitor summary waiters give precedence signallers strategy nice avoiding certain kinds errors inefficient see consider implemenation expensive swith processes consider happens consumer blocked nonempty condition variable producer calls enter item producer adds item buffer calls nonempty signal producer immediately blocked consumer allowed continue consumer removes item buffer leaves monitor producer wakes since signal operation last statement enter item leaves monitor unnecessary switch producer consumer back avoid inefficiency recent implementations monitors replace signal notify notify operation like signal awakens process waiting condition variable one otherwise nothing name implies notify hint associated logical condition might true rather guarantee true process called notify allowed continue leaves monitor awakened waiter allowed continue since logical condition might true anymore waiter needs recheck wakes example bounded buffer monitor rewritten replace b isfull nonfull wait b isfull nonfull wait java built something like two key differences first instead marking whole class monitor remember mark method synchronized every object potentially monitor second explicit condition variables effect every monitor exactly one anonymous condition variable instead writing c wait c notify c condition variable simply write wait notify solution bounded buffer problem java might look like class boundedbuffer buffer b synchronized public void enter item object item b isfull wait b enter item item notifyall synchronized public object remove item b isempty wait item result b remove item notifyall return result instead waiting specific condition variable corresponding condition want buffer non empty buffer non full simply wait whenever make either conditions true simply notifyall operation notifyall similar notify wakes processes waiting rather one waiting longest general process use notifyall rather notify since process waiting longest may necessarily waiting condition notifier made true particular case get away notify cannot producers consumers waiting time messages since shared variables source errors get rid altogether section assume shared memory processes raises new problem instead worrying keep processes interferring figure let cooperate systems without shared memory provide message passing facilities look something like send destination message receive source messsage buffer details vary substantially system system naming destination source specified process may directly name may sort mailbox message queue object used destination send source receive systems allow set destinations called multicast meaning send copy message destination set sources meaning receive message one sources particularly common feature allow source meaning reciever willing receive message process willing send message synchronization send receive block sender immediately continue one common combination non blocking send together blocking receive another possibility rendezvous send receive blocking whoever gets first waits one sender matching receiver waiting message transferred allowed continue buffering messages copied directly sender memory receiver memory first copied sort system memory message size upper bound size message systems small fixed size messages send signals status information separate facility transferring large blocks data design decisions independent example non blocking send generally available systems buffer messages blocking receive useful way say receive receive set sources message based communication processes particularly attractive distributed systems computer networks processes different computers would difficult impossible allow share memory also used situations processes could share memory operating system designer chose allow sharing one reason avoid bugs occur sharing another build wall protection processes trust systems even combine message passing shared memory message may include pointer region shared memory message used way transferring ownership region might convention process wants access shared memory request permission current owner sending message second algorithm project flavor unix message based system user level processes share memory communicate pipes pipe looks like output stream connected input stream chunk memory used make queue bytes one process sends data output stream way would write data file another reads way would read file terms outlined naming indirect pipe acting mailbox message queue send called write unix non blocking recieve called read blocking buffering operating system first glance would appear message size unbounded would actually accurate say message one byte amount data sent write recieved read unbounded boundaries writes erased pipe sender three writes bytes receive two reads asking bytes get back first bytes first time remaining bytes second time continued original semaphore operations called v p respectively people trouble remembering books call signal wait using names operations later monitors available form java using java vehicle illustrating various ideas present languages see similar feature available java many versions unix blanket statement sure lie versions unix allow memory shared processes ways processes communicate pipes solomon cs wisc edu thu oct cst copyright marvin solomon rights reserved
date tue nov gmt server ncsa content type text html last modified thu oct gmt content length cs programming assignment ii cs programming assignment ii process synchronization corrected due october start class contents introduction generalized dining philosophers algorithm algorithm ii specifying graph programming details turn threadscheduler introduction discussion synchronization operating systems often couched metaphor sleeping barber problem cigarette smoker problem bakery problem perhaps venerable dining philosophers scenarios essence models multiple processes able access shared resources without leading deadlock better solutions problem even guarantee fairness processes guaranteed access resources cannot starved project required implement two solutions generalization dining philosophers problem using multithreading synchronization capabilities java simulate action multiple processes competing shared resources tanenbaum offers two solutions first one outlined figure p subject deadlock animated demonstration solution java tutorial second one spelled complete detail c figure solution given edsger dijkstra person made problem first place avoids deadlock putting states philosophers public place using global mutex semaphore inspect implementing two solutions generalized dining philosophers original dining philosophers problem posed dijkstra involved five philosophers sitting around table fork pair philosophers philosophers eating spaghetti tangled required two forks eat subsequent authors generally assume number n philosophers fixed constant necessarily five authors also realized story would much believable forks replaced chopsticks chandy misra generalized problem allow arbitrary pairs philosophers share forks example following diagram shows ten philosophers numbered line represents fork shared pair philosophers forks indicated fork identifiers numbers thus philosopher shares forks three others example philosopher shares fork philosopher fork philosopher fork philosopher picture known graph theory peterson graph algorithm simplest algorithm diners problem hungry philosopher grab forks needs e forks surrounding order start eating fork available simply waits asking next one algorithm lead deadlock philosopher always picks forks increasing order fork identifiers deadlock cannot occur able prove statement example philosopher grab forks order matter forks numbered long two number algorithm ii chandy misra call algorithm hygienic solution diners problem fork either clean dirty fork used eat dirty remains dirty cleaned clean fork remains clean used eating philosopher cleans fork mailing hygienic fork cleaned mailed eating philosopher satisfy requests forks finished eating key issue requests non eating philosopher defer algorithm non eating philosopher defers requests forks clean satisfies requests forks dirty example suppose aristotle berkeley neighbors berkeley eating berkeley finishes eating continues hold shared fork unless aristotle asks berkeley gets hungry simply reuse fork start eating provided get rest forks aristotle wants fork berkeley starts eating take even berkeley hungry yet eating however aristotle grabs fork give eaten least chandy misra show algorithm deadlock free provided initial placement forks acyclic following sense draw arrow head edge graph g points towards process currently holding fork possible start process follow edges around graph returning starting point always obeying directions arrow heads deadlock possible otherwise philosopher ask forks may wait long eat algorithm example one possible placement forks philosopher forks eat right hungry poor philosopher none fork shared philosophers currently held philosopher placement acyclic hence could lead deadlock cycle back specifying graph specification philosopher graph number philosophers forks indication forks shared pairs philosophers given file graph file also indicates initial placement forks give graph files well library class parse worry format library class supplied following interface class graph graph string filename throws filenotfoundexception constructor reads graph file public int numberofphilosophers public int numberofforks public int numberofneighbors int phil many neighbors phil share forks public int forkid int phil int n nth fork shared phil public int neighborid int phil int n phil share nth fork public boolean hasforkinitially int phil int n phil initially hold nth fork first four methods self explanatory last three take two arguments philosopher id phil number range numberofphilosophers number n range numberofneighbors phil return respectively fork id phil nth fork philosopher id philosopher shares indication whether phil holds fork initially forks arranged around philosopher increasing order fork id forkid phil always lowest numbered fork shared phil example figure numberofneighbors n forkid n neighborid n hasforkinitially n true true false programming details general outline program invoked java project peterson peterson name graph file indicates number iterations solutions philosopher represented thread instance class extends thread implements runnable run method class look something like public void run int numberofiterations think takeforks eat putforks think eat simply sleep random amount time numberofiterations specified command line use random class java util thread sleep implement think eat algorithm first solution define semaphore class create instance class represent fork class semaphore semaphore int initialvalue public synchronized void public synchronized void method takeforks simply operation forks order returned graph forkid pubforks operation order method graph hasforkinitially used solution main function look something like public static void main string args make sure correct number arguments args length system err println usage command filename iterations return read file containing graph information try graph graph new graph args catch filenotfoundexception e system err println args e system exit get number iterations cycles second argument int iterations integer parseint args create array forks semaphore forks new semaphore graph numberofforks int graph numberofforks forks new semaphore create array philosophers philosopher phil new philosopher graph numberofphilosophers solaris create scheduler keep us honest threadscheduler sched new threadscheduler sched start start processes int id id graph numberofphilosophers id phil id new philosopher iterations phil id start sched registerthread phil id wait philosophers die int id id graph numberofphilosophers id phil id join sched stop algorithm coding second algorithm going considerably complicated first program forks represented separate objects rather variables philosopher objects instead grabbing forks order hungry philosopher repeatedly cycle forks politely requesting doesn gets always willing respond requests forks even eating depending state thinking hungry eating state requested fork clean dirty may respond giving requested fork may respond negatively remember request philosopher finishes eating goes records requests refused earlier sends forks requesters philosopher need remember field class philosopher state well several pieces information fork shares whether whether clean dirty whether requested neighbor perhaps called philosopher gets hungry get forks doesn return private synchronized void takeforks state hungry forks number neighbors ith fork f thegraph forkid myid p thegraph forkneighborid myid p requestfork f record ith fork clean still forks wait state eating called philosopher finishes eating private synchronized void putforks state thinking number neighbors mark ith fork dirty previously rejected request ith fork previously refused request fork f thegraph forkid myid p thegraph forkneighborid myid p givefork f remember fork called another philosopher request fork returns true request granted immediately false deferred public synchronized boolean requestfork int f find thegraph forkid myid f ok give ith fork right record longer ith fork return true else remember ith fork requested return false called another philosopher give fork previously requested calling requestfork method public synchronized void givefork int forkid find thegraph forkid myid f record philosopher ith fork clean notify give lot thought design data structures used record state philosopher forks note information fork stored two places philosopher shares fork idea state separate fork object program correct information always consistent example exactly one two philosophers think fork given time debugging useful check conditions happen receiving request fork print error message throw exception turn turn copies java files used project well script file showing program action algorithms supplied graph files peterson star must use threadscheduler class runs hand run test iterations philosopher eats times maximum thinking time one second maximum eating time second print message time philosopher changes state eating thinking thinking hungry hungry eating use threadscheduler elapsed timestamp message private random rand new random private static final int maxthink private static final int maxeat private void think try thread sleep int rand nextfloat maxthink catch interruptedexception system println threadscheduler elapsed philosopher myid becomes hungry private void eat system println threadscheduler elapsed philosopher myid starts eating try thread sleep int rand nextfloat maxeat catch interruptedexception system println threadscheduler elapsed philosopher myid finishes eating always code clearly written good internal structure meaningful variable names helpful comments etc code incomprehensible given benefit doubt threadscheduler windows solaris versions java different scheduling policies threads windows version preemptive periodically switches among read threads solaris version runs one thread blocks reason created class simulates preemptive scheduling see concurrent threads really running concurrently solaris use copy cs public src threadscheduler java directory containing rest source files compile javac g threadscheduler java main method wherever start threads create instance threadscheduler threadscheduler scheduler new threadscheduler scheduler start starting new thread register scheduler thread new thread start scheduler registerthread works threadscheduler extends thread thread raises priority high level guaranteed run whenever blocked keeps circular list threads register blocks one running calling thread suspend cyclical fashion awakens individual thread using thread resume sleeps short period thereby giving resumed thread chance run threadscheduler wakes regains control due high priority suspends previous thread resumes new one continues cycle registered threads giving slice time execute copyright marvin solomon rights reserved k m chandy j misra drinking philosophers problem acm trans programming languages systems vol october pp k m chandy j misra op cit page
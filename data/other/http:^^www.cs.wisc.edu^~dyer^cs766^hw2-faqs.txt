date mon nov gmt server ncsa content type text html last modified mon oct gmt content length cs hw hints faqs cs hw hints faqs weights mask w defined weights used based values b c scaled integer arithmetic floating point used convolution operation good d convolution mask result must rescaled multiplying obtain right answer correctly result convolving mask pixel x rescaled rounded result computed x since division truncates mean subtract two images pixel wise difference operation resulting another image create two input images approximately match scale splining creates cool image vscale useful initially scaling two input images splined result interesting since laplacian images positive negative values range best way store images practice pixels values close usually introduce much error truncate laplacian values less greater store image byte per pixel vista type sbtye integer arithmetic operations performed avoid losing precision whenever integer division operation sure compute rounded result b b instead b windows two input images determined images arbitrary sizes aligning center pixels two input images n x m area two overlap make n x m left image using n x m window first image centered center point similarly construct n x m right image second input image either use n x m images input programs stopping level pyramid n m else first padding n x m images size k x k although padding likely introduce artifacts expand operation defined formula maybe answer question expand showing two implementations incorrect implementation tmp m n tmp tmp w m n image row m col n store tmp instead correct version like tmp m n row m mod col n mod tmp tmp w m n image row m col n store tmp correct version suppose row column even say actually use x window input image row values column values thus nine weights kernel used corresponding x x o x o x o o o o o x o x o x o o o o o x o x o x consider weights nine locations turn summing exactly thus multiply result effective sum weights incorrect version still assuming row column even effectively truncating row m col n m n instance computed row index m m row row thus still using x window input image values window repeated effective weights window summing weight window obviously different burt adelson weights row odd column even etc similarly compute effective weight matrices see results similar two algorithms correct version tries interpolate pixel values larger output image looking neighborhood smaller input image makes sense use symmetric gaussian like weight matrix
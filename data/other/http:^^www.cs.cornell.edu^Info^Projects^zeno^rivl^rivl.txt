mime version server cern date sunday dec gmt content type text html content length last modified monday mar gmt resolution independent video language acm multimedia electronic proceedings november san francisco california resolution independent video language jonathan swartz department computer science upson hall cornell university ithaca ny us swartz cs cornell edu brian c smith department computer science upson hall cornell university ithaca ny us bsmith cs cornell edu http www cs cornell edu info projects zeno rivl rivl html work supported funding xerox design research institute us air force contract f acm copyright notice table contents abstract introduction rivl language image operations sequence operations rivl interpreter implementation image computing implementation sequences memory management related future work references abstract common video processing programmers still implement video programs manipulations arrays pixels paper presents language extension called rivl pronounced rival video first class data type programs rivl use high level operators independent video resolution format increasing program portability simplifying code reuse reducing development time paper also describes rivl interpreter strategies interpreter uses optimize rivl programs optimizations include classical programming language optimizations common subexpression elimination order execution image video specific optimizations computing images affect output optimized memory manager introduction order support development multimedia applications programming languages include audio video images true data types characters text numerical values true data types today languages operators multimedia language format independent video images different formats easily intermixed like integers floating point numbers modern programming languages operators multimedia language resolution independent high low resolution input data produces better worse results like single double precision floating point numbers produce less accurate results numeric computations platform independence code reuse useful side effect multimedia programming languages optimizing parallel compilers take existing programs make run faster optimizing multimedia compilers speed multimedia programs rivl pronounced rival language extension optimizing system designed goals mind rivl provides video data type video operators format resolution independent format independence means mpeg video freely intermixed jpeg postscript uncompressed images resolution independence means operations rivl e g cut first five seconds video clip well defined whether film resolution frames per second image size x x features relieve programmer tedious low level details allow runtime system execute rivl program quickly low resolution data crude output e g prototyping debugging slowly high resolution data refined output rivl approach video manipulation significant advantages current approaches rivl programs easier read write maintain low level counterparts rivl code platform independent rivl expresses video image editing operations format resolution independent way rivl separates description video operations implementation allowing rivl runtime system improve execution efficiency rivl programs implemented interpreter rivl extension tcl language approach allows us easily embed rivl applications paper describes design implementation rivl language rivl interpreter optimizer rest paper organized follows section illustrates rivl language series examples section discusses rivl interpreter optimizes image video operations section reviews related work concludes current status future research directions rivl language section illustrates rivl programs series examples since rivl extension tcl rivl programs access primitives tcl language rivl extends tcl two data types images represent still images sequences represent video segments timestamped set images table lists rivl primitives manipulating images sequences table divided five classes input output currently supported formats include pgm ppm jpeg mpeg postscript geometric image operations class move resize image sequence operations speed slow temporally shift sequences assembly class provides cut paste type operations images sequences conversion class provides functions convert images sequences map image operations frames sequence transforms image transforms used paper sections contain examples clarify use image primitives sequence primitives respectively table image sequence primitives type image sequence description operations operations input output im read seq read read image sequence disk im write seq write write image sequence disk geometric im trans seq shift translate image space shift sequence time im scale c seq scale scale image space scale sequence time im rotate c rotate image c around center assembly im crop seq crop crop specified region make new image sequence im concat seq concat concatenate multiple images sequences end end im overlay seq overlay overlay multiple images sequences place conversion ims seq seq ims convert list images sequence seq map apply script image sequence transforms im fade fade image specified percentage im resample resample image specified size im blur apply blur filter image im mask make transparent pixels certain intensity image operations consider following rivl fragment set image im scalec image expr p set image im rotatec image expr p program whirlpool effect image rivl image p floating point value first line calls im scalec shrink image center factor p assigns result image second line calls im rotatec rotate image center p stores result image figure shows effect fragment several values p repeated use set fragment cumbersome remedy problem borrowed idiom scheme operator character appended destructively modifies first argument taking advantage notation rewrite program im scalec image expr p im rotatec image expr p notice destructive operation omits front first argument whereas non destructive form requires artifact caused way tcl implements pass reference point discuss related paper complex effects constructed using tcl constructs looping branching procedure creation recursion rivl program figure creates fractal sierpinski gasket arbitrary image figure output program p figure fractal program output n sequence operations sequence rivl abstraction video thought set time stamped images like image commands sequence commands composed express new operations instance common video editing operation assembly two sequences connected written following rivl fragment assembles first seconds sequence raiders mpg sequence bobo mpg writing result mpg files mpeg format set raiders seq read raiders mpg set bobo seq read bobo mpg seq crop raiders seq write seq concat raiders bobo mpg important primitive rivl seq map seq map applies image effects sequences executing given script image sequence combining resulting images new sequence seq map similar map scheme example consider command seq map clip im resample seq map evaluates template command im resample image clip substituting current image wherever appears template results gathered returned new sequence thus command returns new sequence containing x thumbnail versions images clip sometimes rather applying operation image sequence desirable vary operation time example consider operation fading sequence black effect achieved calling im fade image sequence parameter decreases time case seq map must call procedure parameter indicates time image modified end seq map performs following additional substitutions substitute time stamp current image seconds l substitute length sequence seconds p substitute relative time current image divided l using mechanism fade black expressed seq map clip im fade expr p combined sequence assembly operations seq map simplifies expression effects often used transitions two parts movie example procedure figure connects two sequences transition first parameter transition script passed seq map moviea movieb two sequences joined duration time seconds apply transition effect thus connectwithtransition im fade expr p jack jill connects two sequences jack jill five second fade proc connectwithtransition transition moviea movieb duration set lengtha seq length moviea set lengthb seq length movieb untouched parts first second movie set begin seq crop moviea expr lengtha duration set end seq crop movieb duration lengthb apply timed effect end first movie overlay beginning second movie set mid seq crop moviea expr lengtha duration lengtha set mid seq crop movieb duration set middle seq overlay seq map mid transition mid seq concat begin middle end figure procedure connect two sequences arbitrary transition rivl language extension thus provides powerful notation programming video rivl high level semantic description video operations also allows interpreter optimize execution rivl programs next section describes optimizations rivl interpreter section discusses implementation rivl interpreter first two subsections discuss efficient implementation image sequence operations third subsection discuss memory allocation issues video computing describe rivl custom memory management system implementation image computing two ways optimize still image computing first must make sure individual image operations scales rotations etc efficient issues addressed length graphics literature good algorithms readily available second must intelligent operations call order achieve final result feature rivl allows us exploit second type optimization lazy evaluation also known demand driven execution rivl computes video data needed output display result computation time rivl plan intelligent computing strategy command executed immediately independently rivl interpreter alternates two modes operation graph construction mode graph evaluation mode graph construction mode interpreter evaluates rivl programs recording storing operations directed acyclic graph dag whose edges correspond images whose nodes correspond primitive operations e g scale overlay process typically fast since image operations recorded executed effect dag represents dynamic instruction trace rivl program execution consider following program overlays scaled rotated version image tiger jpg onto image flowers jpg set tiger im read tiger jpg im scalec tiger im rotatec tiger set flowers im read flowers jpg im blur flowers im overlay tiger flowers im write jpg figure shows graph created program im scalec im rotatec implemented pair translations surrounding im scale im rotate translations move origin scale rotate operations center image figure sample image graph call im write triggers graph evaluation mode principle rivl interpreter traverses graph inputs output computing intermediate images output image computed computing images interpreter perform several optimizations two optimizations graph restructuring result region calculation described graph restructuring first optimization modifies graph output equivalent computation efficient modifications include combining swapping adjacent nodes example figure contains six adjacent affine transformations rivl collapses nodes single affine transform figure optimization improves computation speed quality final image reducing number times image resampled result region calculation second optimization introduced shantzis compute regions intermediate image affect final result example program small portion flowers visible final result figure b right sufficient read blur portion rivl calculates regions intermediate images e every edge dag region need region result region region edge region pixels provided edge left node need region edge region pixels needed edge right node finally result region intersection need intersection contains pixels defined values affect final output image pixels inside result region need computed figure b shows regions computed intermediate image example graph particular small region calculated two lower images following optimizations rivl interpreter computes graph result image writes image disk returns processing commands graph construction mode figure restructured image graph b result regions implementation sequences implementation sequences borrows many ideas implementation images since many still image optimizations prove especially beneficial sequence computing use scrolling titles sample task motivate section following program adds scrolling credits last seconds second minute movie set credits ims seq im mask im read credits ps seq map credits im trans expr p seq scale credits seq shift credits expr set raiders seq read raiders mpg set outseq seq map credits raiders im overlay seq write outseq mpg program adding scrolling credits end movie titles stored postscript program generates long image x im mask function makes titles background transparent program converts image one second sequence credits scrolls credits upwards time using seq map scales shifts credits desired time range sec final seq map overlays titles onto raiders movie result written file mpg like image commands sequence commands stored graph called sequence graph sequence computed e g response seq write command figure shows sequence graph program node corresponds one line program sequence graph used generate set image graphs correspond sequence individual frames figure sequence graph scrolling titles suppose want compute frame output sequence time perform two passes sequence graph backward pass forward pass backward pass compute timestamp edge edge timestamp indicates time value edge influences output frame traverse graph seq scale seq shift node encounter potentially alters timestamp top figure shows timestamps computed forward pass build image graph corresponding output frame traverse sequence graph seq read seq map node encounter adds node image graph seq read uses timestamp determine frame read seq map uses timestamp substituting values p bottom figure shows image graph computed compute whole sequence repeat image graph generation algorithm relevant output times increment fps fps desired frame rate frames sec output sequence program ranges resulting graphs merged single compound image graph shown figure figure generating image graph figure image graph entire sequence optimizations section used process compound image graph produce output images along two additional optimizations image subgraph reuse direct transfer detection image subgraph reuse figure subgraph containing im read credits ps im mask replicated many times efficient use single subgraph multiple output edges shown figure way pixels credit ps read masked various im trans nodes share common input general rivl detects merges redundant image subgraphs whenever possible form common subexpression elimination direct transfer detection example first seconds raiders mpg appear unchanged output obvious optimization avoid unnecessary decompression compression copying compressed data directly output formats mpeg direct copying always possible every frame since mpeg sequences contain frames encoded differences frames cannot decoded isolation however mpeg streams often divided groups pictures gops usually frames long independent gops reading writing mpeg rivl transfers groups pictures directly whenever possible figure image graph entire sequence shared subgraph memory management addition optimizing image sequence calculation rivl interpreter contains custom memory management module cache previously computed images cope large images understand utility caching images consider evaluation graph figure output im mask node used many times advantageous cache image rivl memory manager detects case freeing image longer needed current graph evaluation another issue whether store images graph evaluation ends interactive applications rivl often require repeated evaluations slightly changing graph language restricts way image graphs modified image associated edge remains accurate lifetime graph cached unfortunately special knowledge images cache future graph evaluations principle user access edge ever created mistakenly discarding data nonfatal since always recompute data mistakes hurt performance address issue rivl provides im priority command allow applications set priority image memory manager discards low priority images keeps high priority images memory instance video editor built using rivl calls im priority raise priority displayed images results special effects quickly viewed looking algorithms heuristics automatic priority adjustment example images generated expensive operations images referenced repeatedly past candidates high priority initial implementation rivl treated images indivisible memory buffers unfortunately representation performed poorly large images rivl memory manager divides large images non overlapping pages manageable size figure pages handled independent entities memory manager allowing image cached parts addition large images considerable blank space efficiently represented set non contiguous pages figure b figure dividing large image b representing sparse image illustrate utility rivl memory management policy consider execution scrolling titles program program standard memory model entire image read virtual memory buffer duration program assuming color image requires mb storage contrast rivl accomplishes task follows x title region divided ten equally sized pages given rivl current maximum page size rivl allocates loads masks page data necessary results call im mask cached future requests rivl discards pages soon longer needed memory footprint mb enough rivl hold two pages summary rivl interpreter uses variety strategies optimize execution rivl programs graph restructuring combining reordering nodes graph speed result region calculation computing parts image affect output direct transfer detection copying compressed data directly output possible image subgraph reuse sharing common subexpressions image graph image caching caching images needed later graph evaluation image subdivision dividing large images manageable pieces related future work many commercial packages available provide software libraries image manipulation functions use demand driven execution achieve similar optimizations mentioned section include pixar system described shantzis silicon graphics imagevisionlibrary holzmann popi allows image transformations specified concise expressions run time mechanism permits rapid prototyping new image primitives adapting idea rivl none mentioned systems provide language support motion video systems e g data explorer khoros provide graphical programming environment image programs expressed flowcharts although way expressing image operations improvement pixel manipulation limitations flowcharts expressing complex programs well known furthermore support motion video operations systems limited non existent matthews gloor makedon videoscheme combines apple quicktime movie player scheme based video manipulation language videoscheme user works objects close underlying implementation video data pixel arrays frames low level access gives users considerable flexibility creating new image operations example algorithms detecting cuts video easily built pixel array primitives contrast rivl high level abstraction allows exploit delayed computation improved efficiency resolution independence makes programs portable rivl implemented lines c code lines tcl code ported sun os hpux linux operating systems rivl used build simple video editor rivl editor found http www cs cornell edu info projects zeno rivl rivl html rivl language still evolving extending core set rivl primitives support types video processing image analysis computer vision morphing right primitives hope build rapid prototyping environment exploring video content processing also building parallel implementation rivl interpreter using workstation clusters implementation rivl program run quickly using low resolution images small cluster slowly using high resolution images small cluster quickly using high resolution images large cluster interpreter automatically parallelize rivl program using coarse grained parallelism one image one process fine grained parallelism one image multiple processes references aho sethi ullman compilers principles techniques tools reading mass addison wesley pp data explorer software package ibm j d foley et al computer graphics principles practice second edition reading mass addison wesley holzmann gerald j popi bell laboratories murray hill nj d le gall mpeg video compression standard multimedia applications communications acm april vol num pp matthews james peter gloor fillia makedon videoscheme programmable video editing system automation media recognition acm multimedia proceedings pp w b pennebaker jpeg still image data compression standard van nos reinhold new york poskanzer jef extended portable bitmap toolkit pbmplus postscript adobe systems incorporated mountain view ca shantzis michael model efficient flexible image computing siggraph proceedings pp ousterhout john k tcl tk toolkit addison wesley massachusetts rasure kubica khoros application development environment experimental environments computer vision image processing editor h christensen j l crowley world scientific silicon graphics inc imagevision library silicon graphics inc mountain view ca swartz jonathan smith brian c rivl resolution independent video language submitted tcl tk workshop july toronto ca http www cs cornell edu info projects multimedia rivl tcl tk ps footnotes rivl image type unrelated tcl tk canvas image type
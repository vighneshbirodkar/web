server netscape commerce date tuesday jan gmt last modified wednesday oct gmt content length content type text html notes programming c notes programming c rob pike bell laboratories introduction kernighan plauger elements programming style prentice hall important rightly influential book sometimes feel concise rules taken cookbook approach good style instead succinct expression philosophy meant book claims variable names chosen meaningfully doesn follow variables whose names small essays use even better isn maximumvalueuntiloverflow better name maxval think follows set short essays collectively encourage philosophy clarity programming rather giving hard rules expect agree opinion opinions change times ve accumulating head paper long time based lot experience hope help understand plan details program ve yet see good essay plan whole thing find idiosyncratic fine disagree fine make think disagree better circumstances program way say say program way think expresses best re trying accomplish program consistently ruthlessly comments welcome issues typography program sort publication meant read programmer another programmer perhaps days weeks years later lastly machine machine doesn care pretty program program compiles machine happy people sometimes care much pretty printers mechanically produce pretty output accentuates irrelevant detail program sensible putting prepositions english text bold font although many people think programs look like algol report systems even require edit programs style clear program made clearer presentation bad program made laughable typographic conventions consistently held important clear presentation course indentation probably best known useful example ink obscures intent typography taken even stick plain old typewriter like output conscious typographic silliness avoid decoration instance keep comments brief banner free say want say program neatly consistently move variable names ah variable names length virtue name clarity expression global variable rarely used may deserve long name maxphysaddr say array index used every line loop needn named elaborately saying index elementnumber type calls upon text editor obscures details computation variable names huge harder see going partly typographic issue consider array vs elementnumber array elementnumber problem gets worse fast real examples indices notation treat pointers also require sensible notation np mnemonic nodepointer consistently use naming convention np means node pointer easily derived next essay aspects readable programming consistency important naming call one variable maxphysaddr call cousin lowestaddress finally prefer minimum length maximum information names let context fill rest globals instance typically little context used names need relatively evocative thus say maxphysaddr maximumphysicaladdress global variable np nodepointer pointer locally defined used largely matter taste taste relevant clarity eschew embedded capital letters names prose oriented eyes awkward read comfortably jangle like bad typography use pointers c unusual allows pointers point anything pointers sharp tools like tool used well delightfully productive used badly great damage sunk wood chisel thumb days writing pointers bad reputation academia considered dangerous dirty somehow think powerful notation means help us express clearly consider pointer object name exactly object sounds trivial look following two expressions np node first points node second evaluates say node second form expression simple interpret must know node node related probably unspecified rules surrounding program nothing expression isolation show valid index node let alone index element want j k indices node array easy slip compiler cannot help particularly easy make mistakes passing things subroutines pointer single thing array index must believed belong together receiving subroutine expression evaluates object inherently subtle error prone address object correct use pointers simplify code parent link type vs lp type want next element type parent link type lp type advances rest expression must stay constant pointers one thing advance typographic considerations enter stepping structures using pointers much easier read expressions less ink needed less effort expended compiler computer related issue type pointer affects used correctly allows helpful compile time error checking array indices cannot share also objects structures tag fields reminders type np left sufficiently evocative array indexed array well chosen name expression end longer node left extra characters become irritating examples become larger rule find code containing many similar complex expressions evaluate elements data structure judicious use pointers clear things consider goleft p left p right left else p right p left right would look like using compound expression p sometimes worth temporary variable p macro distill calculation procedure names procedure names reflect function names reflect return functions used expressions often things like need read appropriately checksize x unhelpful deduce whether checksize returns true error non error instead validsize x makes point clear makes future mistake using routine less likely comments delicate matter requiring taste judgement tend err side eliminating comments several reasons first code clear uses good type names variable names explain second comments aren checked compiler guarantee re right especially code modified misleading comment confusing third issue typography comments clutter code comment sometimes almost exclusively use introduction follows examples explaining use global variables types one thing always comment large programs introduction unusual critical procedure mark sections large computation famously bad comment style add one worse ways add one laugh wait see real life avoid cute typography comments avoid big blocks comments except perhaps vital sections like declaration central data structure comments data usually much helpful algorithms basically avoid comments code needs comment understood would better rewrite easier understand brings us complexity programs complicated complex need solve problems efficiently mostly bad design skip issue big one programs often complicated microscopic level something address rule tell program going spend time bottlenecks occur surprising places try second guess put speed hack ve proven bottleneck rule measure tune speed ve measured even unless one part code overwhelms rest rule fancy algorithms slow n small n usually small fancy algorithms big constants know n frequently going big get fancy even n get big use rule first example binary trees always faster splay trees workaday problems rule fancy algorithms buggier simple ones re much harder implement use simple algorithms well simple data structures following data structures complete list almost practical programs array linked list hash table binary tree course must also prepared collect compound data structures instance symbol table might implemented hash table containing linked lists arrays characters rule data dominates ve chosen right data structures organized things well algorithms almost always self evident data structures algorithms central programming see brooks p rule rule programming data algorithms details algorithms often encoded compactly efficiently expressively data rather say lots statements reason complexity job hand due combination independent details encoded classic example parsing tables encode grammar programming language form interpretable fixed fairly simple piece code finite state machines particularly amenable form attack almost program involves parsing abstract sort input sequence independent actions constructed profitably data driven algorithm perhaps intriguing aspect kind design tables sometimes generated another program parser generator classical case earthy example operating system driven set tables connect o requests appropriate device drivers system may configured program reads description particular devices connected machine question prints corresponding tables one reasons data driven programs common least among beginners tyranny pascal pascal like creator believes firmly separation code data therefore least original form ability create initialized data flies face theories turing von neumann define basic principles stored program computer code data least else explain compiler works functional languages similar problem o function pointers another result tyranny pascal beginners use function pointers function valued variables pascal using function pointers encode complexity interesting properties complexity passed routine pointed routine must obey standard protocol one set routines invoked identically beyond business alone complexity distributed idea protocol functions used similarly must behave similarly makes easy documentation testing growth even making program run distributed network protocol encoded remote procedure calls argue clear use function pointers heart object oriented programming given set operations want perform data set data types want respond operations easiest way put program together group function pointers type nutshell defines class method o o languages give course prettier syntax derived types conceptually provide little extra combining data driven programs function pointers leads astonishingly expressive way working way experience often led pleasant surprises even without special o o language get benefit extra work control result cannot recommend implementation style highly programs organized way survived comfortably much development far better less disciplined approaches maybe discipline forces pays handsomely long run include files simple rule include files never include include files instead state comments implicitly files need included first problem deciding files include pushed user programmer way easy handle construction avoids multiple inclusions multiple inclusions bane systems programming rare files included five times compile single c source file unix usr include sys stuff terrible way little dance involving ifdef prevent file read twice usually done wrong practice ifdef file file includes result often thousands needless lines code passing lexical analyzer good compilers expensive phase follow simple rule rob pike rob research att com sep
mime version server cern date monday dec gmt content type text html content length last modified thursday oct gmt mobile object layer dynamic irregular computations mobile object layer dynamic irregular computations nikos chrisochoides chris hawblitzel motivation work implementation runtime support dynamic irregular computations work consisted two parts implementing runtime library mobile objects handle migration objects one processor another handle communication objects parallelizing adaptive mesh refinement amr program top mobile objects ports amr algorithm starts uniform mesh pde solved recursively refines areas mesh need finer mesh achieve desired level accuracy pde solution cannot tell runtime areas need refining sort dynamic load balancing necessary parallel implementation amr approach break mesh small pieces called grid components balance load transferring grid components heavily loaded processors lightly loaded processors contrast approaches involving centralized decision making system completely decentralized collective communication required processors wait centralized decisions made proceeding work amr algorithm grid components follows mesh starts single root grid component areas grid component need refining root grid component spawns many smaller child grid components finer meshes children spawn children recursively forming tree grid components order balance load grid components move one processor another happens pointers grid components must remain valid conventional global pointers consisting pairs processor address object change global pointers object become invalid deal use mobile pointers remain valid even objects move keep track mobile pointers processor directory uses hold location mobile objects entries directory may current messages sent best guess object resides messages forwarded true location object current interface mobile objects layer contained mobile h mobile pointers implemented structure containing number processor created object index number unique processor addition epoch number used guard stale data members structure form unique name every mobile object system directory consists set tables table holds information objects originating one processor send message object specified mobile pointer processor checks table corresponding originating processor mobile pointer uses index field mobile pointer look specific entry table entry holds processor object located object local processor entry also holds local memory address object entry may true current location object best guess processor object resides entry table originating processor field mobile pointer serves best guess location object entry looked directory message sent mobile object remote processor turns object moved longer located processor specified directory entry message automatically forwarded possibly multiple times correct destination directory entry later updated current information subsequent messages sent mobile object go directly correct destination two functions mob objreq mob msgreq form core mobile objects communication interface application call mob objreq send request object one processor another request invokes user handler remote processor selects object sends object back requesting processor handler uninstalls object remote processor calling mob uninstallobj function takes new location object argument remote processor knows forward incoming messages object arrives requesting processor application installs object mob installobj send message object application calls mob msgreq sends small message processor holds object specified mobile pointer message arrives user handler invoked perform action using object sending large reply message back current implementation mob objreq mob msgreq uses ports functions ports put ports rsr handler processor one queue processor system hold incoming messages messages data one queues destination processor using ports function ports put put followed ports rsr handler invokes handler destination process message destination processes incoming messages sends replies back free space queue communication interface compromise handles buffering forwarding small fixed sized messages sent mob msgreq interface also handled buffering forwarding large messages would easier use difficult implement think arbitrary sized message buffering forwarding would worth implementing beyond scope project current implementation mobile objects mobile c still features unimplemented simple example mobile objects used small test file provided parallelized amr code contained directory files main c amr c grid level h good places look amr program creates one mobile object per grid component handle grid component data uses one thread grid component handle control code mesh refinement tree construction equations solved mesh constructed one attractive aspects threads mobile objects approach easy experiment different load balancing strategies application without drastically altering application code current policy fairly simple processors organized grid actually d ring number threads processor drops certain value currently processor sends requests neighbors asking grid components processor receives request grid components checks list available grid components see work send sends grid component whose position furthest towards position requesting processor instance request comes processor left leftmost grid component sent timing results timing measurements amr code made processors sp following plots show much time spent processor useful work much time went communication thread management measurements shown functions time apparent balance computation communication change mesh refinement progresses communication times shown include overhead associated load balancing including handler execution packing unpacking objects note may want make web browser wide enough display two plots side side best performance obtained early computation small objects near root grid component tree quickly spawn large amounts work processors processor spends relatively little time fetching components lot time useful work components components decendants however computation progresses processors spend time fetching components components near bottom grid component tree therefore lead relatively little work processors struggle find enough grid components keep busy near end refinement although processors least work computation request work running completely running threads resultant communication overhead leads low performance period time two processors communication also impact processors must service requests work plots show amr difficult load balance explosive growth grid component tree unpredictable places however tests somewhat worst case situation test one part one time step real amr application application using amr grid component tree similar structure one time step next fact may held fixed several time steps refinements longer completely unpredictable load balancing occur gradually many time steps contrast centralized algorithms must completely redistribute load mesh changes significantly amr implementation based threads moving objects able incrementally balance load preserving data locality holding communication costs implemented yet tools built provide easy platform construct full amr application
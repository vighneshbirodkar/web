mime version server cern date monday dec gmt content type text html content length last modified wednesday oct gmt cs questions answers phase question re difficulty understanding abstraction process queues re asked implement phase one project cs understand removeproc supposed specification says remove first element process queue whose tail pointer tail pointed tp scan proctable first element tail pointer assume mean element p next structure type proc identical tp answer function removeproc precisely spec says consider queue q queue fifo list head element tail element consider pointer tail element q let pointer p consider pointer p let call tp removeproc assumes know tp goal remove q head element q namely devise smart efficient implementation queue data structure makes task easy question cannot read files types h const h particular try access directory cs hoca h get back permission denied answer try cd directory won able instead use unix cp command copy files cs hoca h directory following work tried dahlia sunlab dahlia cd dahlia cp cs hoca h types h types h dahlia cp cs hoca h const h const h question believe function pg outblocked semadd p outblocked p listed answer outblocked really takes p parameter point however need know address semaphore p blocked maybe instance adding fields given data structures good idea question assignment says add fields proc semd make efficient since abstracting module close implementation ask queue implementation pointer tail head tail usual thus removeproc involve search along whole list tail pointer point something type proc point intermediate type points head tail queue answer yes add fields proc semd structures however try resist temptation add fields without first thought simpler efficient solution exists require implementing queue abstraction taking care function removeproc happens instance adding fields structures would probably serve make things complex less efficient specific removeproc efficiently implemented structure fields already without involving search along whole list suggest also tail pointer way must point last element queue point element type proc question c pcc compiles old style c expect function declarations export files pcc keeps giving core dump try compile export file answer indeed pcc uses old c syntax far set extern declarations e file refer example appendix hoca documentation file queue e question hi compiled modules gcc first along tester module could use awesome debugging power gdb moving graphically pleasing somewhat less powerful chip simulator thought others might benefit strategy wonder question ed might pass via web answer using gcc compile debug modules good idea know use gdb however keep mind executable compiled gcc run chip gcc produces executable sparc chip point eventually compile files using pcc remember pcc ansi compliant used ansi c gcc code change back pre ansi notation beginning next phase gcc probably less useful since need look closely happens chip registers memory friendly chip interface glad help phase question instruction called stit chip mean read value stored answer instruction named stit infer value comparing current time day time day last time loaded question sys return total cpu time used process currently used cpu time process process answer sys returns question interrupt priority higher lower priority answer believe higher care question set initial running area nucleus use stst point guarantee processor kernel mode answer program runs default kernel mode use stst problems question could please tell get value status register length register io device table page chip documentation doesn seem help much actually value length register need retrieved furthermore supposed pass two values appropriate process necessary save corresponding entry process table answer first device completes o values status length register returned device registers device device registers located chip memory interrupt area far accessing area look const h find following definition define begindevreg beginning device registers looking value lenght register need retrieved terminal printer devices see sections going pass values follows process waiting o semaphore device returned values simply copy values registers process waiting also unblock process process waiting copy returned value buffer dedicated device one declared initialization time process initiated o eventually retrieve values question need distinguish caller running inside trap handler really mean passing trap sys anyway answer let answer question reverse order sys anyway sys called initialize old new trap areas kept process opposed trap areas kept nucleus low memory addresses job least decide initialize areas assume initialized values passed registers look example initialization browsing test program really mean pass trap passing trap really means invoking trap handler located nucleus rather higher layer operating system trap passed appropriate old new trap areas calling process must initialized calling sys attempt pass trap made sys invoked trap type executed calling process must terminated passing trap involves copying state calling process old area copying state contained new trap area calling process state maintained process table possible implementation passing mechanism would call movblk twice first time copy running p old trap area second time copy state stored new trap area running p see load new state using ldst rather modify state running process proc table implementation nucleus trap handler finishes calling process gets run actually run higher level trap handler need distinguish caller running process may may depending implementation mine reason caller may different running process easy see consider sys trap handler concentrate sys result p operation calling process may blocked new process elected next run using caller vs running trick one figure withn sys trap handler event taken place load new running process appropriate value less clear caller running trick may useful prog mm even sys traps sys instructions greater traps passed new state loaded instruction call passup never executed question nesheet asked today class implementation check trap areas initialized e right sys executed done within call passup caller process executed sys caller terminated new process designated next run case control indeed reach code passup caller running check allow correctly reload interval timer
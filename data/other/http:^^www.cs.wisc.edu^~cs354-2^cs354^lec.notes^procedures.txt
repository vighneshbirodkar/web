date tue nov gmt server ncsa content type text html last modified wed oct gmt content length lecture notes chapter procedures chapter procedures procedures introduction procedures procedures reuse code simplifies program writing modular code facilitates modification allows different programmers write different parts program etc assembly languages typically provide little support procedure implementation get build mechanism implementing procedures already know first terms need pascal begin x larger b call end header parameters function larger one two integer integer begin one two larger one body else larger two end c x larger b call header parameters int larger int one int two one two larger one body else larger two steps execution procedure save return address procedure call execute procedure return return address instruction following call procedure call jump branch first instruction procedure return jump branch return address mal implementation sal procedure call la rtn b proc one procedure call rtn next instruction la rtn b proc another procedure call rtn next instruction proc st instruction procedure jr jr new instruction unconditional branch jump actually address contained register specified mips r mal actually provides convenient instruction procedure calls jal procname things places address instruction following register ra choice arbitrary fixed branches jumps address given label procname example re written jal proc jal proc proc st instruction procedure jr ra ra alias one problem scheme happens procedure calls recursion procedure calls another procedure nesting using jal value register gets overwritten jal instruction return addresses lost unrecoverable error needed handle problem way save return addresses generated recursive subroutine known ahead time many times subroutine called data generated dynamically program running best way save dynamically generated data stack system stack stack frequently used implementing procedure call return many computer systems predefine stack system stack static defined program written compile time dynamic defined program executed run time case amount storage cannot determined run time size system stack large theory infinitely large practice must size limit address program system stack grows towards smaller addresses large addresses terminology people say stack grows memory means stack grows towards smaller memory addresses picture would show address bottom unlike picture vague terms unless know picture looks like mips system stack defined grow towards smaller addresses stack pointer points empty location top stack stack pointer register also called sp defined program execution begins push mal sw sp replaced whateger register sub sp sp contains data pushed sub sp sp sw sp pop mal add sp sp replace register number lw sp lw sp add sp sp note sp used purpose stack pointer lost example using system stack save return addresses jal doit jal doit doit sw ra sp save return address sub sp sp jal another would overwrite return address saved add sp sp restore return address lw ra sp jr ra stack frames activation records compiler point view bunch things go stack relating procedure call return include return address register parameters various registers procedure different requirements numbers parameters size many registers ones need saved stack compose stack frame activation record specific procedure space stack frame gets placed stack time procedure called taken stack time return occurs stack frames pushed popped dynamically program running example jal jal b jal c jal d jr ra b jal d jr ra c jal e jr ra d jr ra e jr ra show stack trace calling sequence code skeleton one procedures jal c jal d jr ra sub sp sp allocate frame sw ra sp save return address jal c jal d lw ra sp restore return address add sp sp remove frame stack jr ra return notes allocation removal frame done within body procedure way compiler need know size procedure frame accesses frame done via offsets stack pointer parameter passing parameter argument little support implementing procedures many assembly languages little support passing parameters procedures remember comes implementation convention programmer follow conventions passing parameters means getting data place set aside parameters calling program procedure need know parameters calling program places possibly uses values returned procedure procedure uses parameters note parameter passing hll specifies rules passing parameters basically types parameters note language offer types call value c pascal parameters declared without var front variable name fortran doesn type parameter parameter passed may modified procedure implemented passing copy value call value really implies procedure modify value copy passed value changed outside scope procedure call reference fortran pascal var type parameters parameter passed subroutine modified modification seen outside scope subroutine sort like access global variable many ways implementing variable types call value parameter type allowed implement reference type parameter pass address variable parameter access variable made address done c simplest mechanism registers calling program puts parameter specific registers procedure uses example add put parameter register jal decrement move recopy parameter correct place decrement add jr ra notes trivial example since procedure line long use within procedure convention parameters passed specific registers procedure could used decrement value registers copy value register first copy afterwards historically significant mechanism parameters stack place parameters procedure function activation record procedure sub sp sp allocate space parameters sw sp place parameter ar proc sw sp place parameter ar proc jal proc proc sub sp sp allocate remainder ar proc assume fixed size big activation record lw sp retrieve parameter use lw sp retrieve parameter use parameters procedure calculations add sp sp remove ar proc jr ra calling program allocates space parameters places parameters stack calls procedure deallocates remainder ar procedure procedure allocates ar remainder ar deallocates ar procedure least mips convention passing parameters registers first parameters passed registers procedures use registers parameters nested subroutine calls registers used parameters values would lost like return address would lost jal saved possible solutions non recursive nested calls procedure associated section memory nested call made current parameters stored memory return nested call current values restored recursive calls current parameters stored stack nested call return nested call current parameters restored general layout second option used fewer parameters procedure layout allocate remainder ar put return address stack ar procedure procedure calculations set call proc place current parameters ar procedure allocate ar proc set parameters proc call proc jal proc copy return values pop current parameters stack back procedure calculations presumably using procedure parameters back get procedure return address ar return jr ra parameter passing trivial example contains nested calls saves current parameters stack set procedures following items go activation record return address frame pointer parameters local variables may overlap saved registers mechanism procedure call caller gets parameters correct location space allocated part activation record control transfered procedure procedure return put return values correct location restore anything needs restored return address callee saved registers frame pointer remove activation record jump return location guidelines parameters passed stack want caller callees activation records use frame pointer reduces amount code gives better level abstraction depending conventions implementations amount space allocated activation record may different amount space removed callee allocates space parameters stack caller callee allocate space mips always allocate space activation record parameters even less
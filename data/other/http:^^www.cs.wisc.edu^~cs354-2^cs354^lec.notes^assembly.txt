date tue nov gmt server ncsa content type text html last modified mon oct gmt content length lecture notes chapter assembly chapter assembly process mips floating point hardware floating point arithmetic could done hardware software hardware fast takes chip real estate software slow takes space memory software insignificant amount assembly language programmer cannot tell used except calculations quite lengthy could noticeable time difference software could times slower mips specifies offers hw approach control hw integer arithmetic hw located vlsi chip packs full mips architecture designed chips accept instructions execute chips called coprocessors integer one called c coprocessor one fl pt arithmetic called c coprocessor alternative name c r c r c c mem c listens instruction sequence partially decodes instruction gets one meant execute executes time c ignores instruction meant c correct amount time fetches another instruction registers meant integers registers meant floating pt values c bit registers integer instructions access registers fl pt instructions access c registers fl pt registers must used restricted ways explanation comply ieee standard fl pt arithmetic hw must support fl pt types single precision double precision discussed use single precision means fl pt number fits fl pt register double precision fl pt number requires fl pt registers since double precision numbers bits long sgl prec number stored always placed least significant word pair registers bit f f f f f means purposes storing fl pt values registers really even numbered ones must use number corresponding registers use even numbered ones instuctions coprocessor load store move fl pt operations load store instructions lwc ft x rb address data x rb note rb r register read data place fl pt register ft address calculation data goes different move instructions mtc rt fs move contents r register rt fl pt register fs really copy operation translation done bit copy mfc rt fs move contents fl pt register fs r register rt really copy operation translation done bit copy floating point arithmetic instructions add subtract multiply divide specifies fl pt registers convert single precision double precision double precision single precision comp called fixed point format single precision etc operations convert move data within fl pt registers convert like given sal must convert move move r convert comparison operation set bit set bits based comparison branch instruction use information assembly process computer understands machine code people compilers write assembly language assembly machine source assembler code code assembler program deterministic program translates instruction machine code past one one correspondence assembly language instructions machine language instructions longer case assemblers days made powerful rework code mal tal mal instructions accepted assembler tal subset mal instructions directly turned machine code lots mal instructions direct tal equivalent determine whether instruction tal instruction look appendix c instruction tal instruction assembler takes non mips mal instructions synthesizes mips instructions examples mul becomes mult mflo mips architecture registers hold results integer multiplication division called hi lo bit register mult places least significant bits result lo significant hi operation mflo mtlo mfhi mthi register lo register hi move move data moved register hi lo one operand needed tell data coming going addressing modes exist tal lw label becomes la label lw becomes lui xmspart label ori xlspart label lw lui xmspart label lw xlspart label instructions immediates synthesized instructions add sp sp becomes addi sp sp add instruction requires operands registers addi one operand immediate instructions classified immediate instructions mips include addi addiu andi lui ori xori add expanded back add tal implementation o instructions putc becomes li move syscall addi add syscall getc becomes li syscall move addi syscall add puts becomes li move syscall addi add syscall done becomes li syscall addi syscall assembly assembler job assign addresses generate machine code modern assembler fly translate synthesize accepted assembly language instructions available architecture assign addresses generate machine code generated image memory must look like program executed simple assembler make complete passes data complete task pass create complete symbol table generate machine code instructions branches jumps jal la etc instructions rely address machine code pass complete machine code instructions didn get finished pass assembler starts top source code program scans looks directives data text space word byte float instructions important separate memory spaces data instructions assembler allocates seqential order scans source code program starting addresses fixed program assembled data instructions start address example data word byte n space address contents x x x x x x x c x msbytes part declaration assembler align data word addresses unless specify otherwise simple example machine code generation simple instruction assembly language addi opcode rt rs immediate machine code format opcode rs rt immediate opcode bits defined rs bits encoding rt bits encoding bit instruction addi re spaced x f example data word word word text start la loop lw mult b loop done solution symbol table symbol address start loop memory map data section address contents hex binary c translation tal code text start lui x la ori x loop lw mult beq loop b loop ori done syscall memory map text section address contents hex binary c lui c ori cc lw c mult fffd beq ori c syscall explanation assembler starts beginning ascii source code scans tokens takes action based tokens data directive tells assembler come next placed data portion memory label put symbol table assign address assume program data starts address x branch offset computation execution time taken branch contents pc sign extended offset field pc pc points instruction beq offset added assembly time byte offset target addr beq addr hex ordered give positive result byte offset bit offset field throw away least significant bits always added back execution time byte offset becomes offset field jump target computation execution time significant bits pc target field pc bits assembly time get target field take bit target address eliminate least significant bits word address eliminate significant bits remains bits goes target field
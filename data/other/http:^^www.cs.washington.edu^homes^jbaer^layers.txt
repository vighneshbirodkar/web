date tue dec gmt server ncsa content type text html last modified tue jun gmt content length static layer analysis c programs static layer analysis c programs jeremy baer department computer science engineering university washington abstract principles hierarchical layered approach software design discussed preliminary work software tools allow enforcement layered structure forward engineering extraction layered structure pre existing c language source code presented introduction idea layered design new software engineering parnas wrote building software layers virtual machines defined uses relation components software system p paper advocates hierarchical design approach component level uses component component level hierarchy uses least one component level component level higher uses relation defined component uses component b correct operation depends upon existence correct implementation b parnas argues system built way uses hierarchy exists components level hierarchy comprises usable subset complete system clearly desirable property system particularly perspective code reuse system development families similar systems developed code base another design methodology parnas also written support information hiding p p information hiding hierarchical layered design structure essentially orthogonal one another seem valuable techniques applied problems software engineering however considerable language support developed information hiding plethora object oriented object based languages allow enforcement information hiding little work done regard language support layered systems paper presents preliminary work two tools lcc lce allow enforcement layered structure forward engineering extraction layered structure one exists pre existing c language code tools utilize parnas uses relation establishing layers instead work simpler invokes relation parnas points although invokes uses often coincide identical component may invoke component b actually depend correctness b correct operation similarly component may use component b without ever directly invoking simple example might components b communicate setting reading global variables invokes relation chosen simplicity implementation direct applicability forward reverse engineering computing whether uses hierarchy exists collection source files would seem require one access fairly precise specification system components order determine whether correct operation component depends component b must know correct operation thus order enable feasible implementation tools discussed paper decided would operate layers invokes relation layered c checker lcc lcc simple tool intended use forward engineering context enforcement layered design structure development source code desired lcc checks annotated c program determine whether level boundaries assigned functions maintained set allow recursive functions since recursive functions would normally reported error function calls calling function level contrary normal layered structure additionally flexibility may desired number layers invocations cross lcc reports errors strict definition layered system function level call functions level may easily attainable abstract level inserting dummy functions intervening layers across multi layer invocation would otherwise reach typically desirable introduce lots functions source code whose purpose call functions thus lcc may instructed allow invocations cross k layers also option allow invocation cross number layers long course going higher level lower level lcc utilizes simple fairly ad hoc parsing mechanism recognize annotations extract call graph source call graph extractor perhaps overly simplistic builds graph based solely tokenized function calls whose textual names match one functions declared source result completely ignores invocations occur use function pointers also performs reachability analysis code may thus include invocations never happen comments also apply lce discussed later following sample output running version lcc simple program strict layered structure followed run lcc turns lcc strict layered structure cindy layered c lcc l r foo c functions level level foo c abs foo c fact foo c power foo c d power level foo c cos foo c exp level foo c func level foo c find root level foo c main foo c illegal level crossing abs level invoked find root level foo c illegal level crossing abs level invoked main level foo c illegal level crossing abs level invoked main level exiting errors cindy layered c lcc l lcc cc functions level level test cc functionlookup test cc nexttokenstr level test cc handleerror test cc findfunctions test cc checklayers level test cc main level boundaries maintained cool two different approaches may taken respect annotations done lcc one approach make lcc integral part compilation process approach special keyword level added c order allow assignment levels different functions directly function declaration function body level keyword must appear along numeric level assignment example int foo double x level function body lcc checking level boundaries succeeds outputs intermediate c files annotations stripped execs cc gcc files approach advantage brings support layers closer language level disadvantage approach moment stems fact lcc contain full c parser thus syntax errors may confuse lcc causing output layer related errors without telling syntax errors fact case never actually produce intermediate files run real compiler programmer essentially stuck trying find error hand removing annotations compiling neither satisfactory solutions second approach neither advantages disadvantages first view lcc optional static checker version lcc levels specified annotations enclosed c comments still utilize level keyword live place source code since comment source code still compiled using regular c compiler approach example looks like int foo double x level function body lcc performs basic analysis except must locate particular comments since normally skips comments find annotations version lcc using second approach currently much usable version implementing first approach author belief bringing layer support closer language level first approach ultimately desirable given addition complete c parser addition layer syntax lcc layered c extractor lce lce similar lcc checks c source code see boundaries levels maintained however rather using source annotations determine level function assigned lce automatically generate mapping functions levels thus lce perhaps applicable process reverse engineering program understanding forward engineering process options recursion invocation layer crossing thresholds etc lcc available lce lce works first extracting call graph source manner lcc performs recursive depth first search call graph starting main level counter incremented every level recursion function called current level level function set current level long already deeper note lce assigns levels inverted order normally accepted lce namely main level functions lower hierarchy higher numbered levels lcc optionally use inverted layer ordering lce uses exclusively performing depth first search call graph yield one possible assignment layers namely assignment function gets assigned highest possible layer hierarchy may however optimal assignment layers one might imagine example desirable scheme mapping functions layers would minimize number layers crossed invocation rather addressing algorithm however approach inspired reflexion models mns taken lce modified recognize level annotations used lcc allows user set levels certain functions stone annotation see desired level boundaries maintained lce fixes level functions annotated still uses depth first search map levels rest functions following two sample executions lce source unix command agrep turns neither programs strict layered invokes structure invokes hierarchy exists agrep invocations cross less level boundaries allowable layer crossings set one offending invokes test whether layer crossing truly necessary calling function annotated fixed one level lower depth first search placed however test re run layers separation two functions remained agrep example also illustrates another capability lce side effect depth first searching call graph function functions never visited depth first search may never called lce flags possibility cindy layered c lce l r lce cc functions level level lce cc main level lce cc findfunctions lce cc findcallgraph lce cc assignlayers lce cc checklayers level lce cc assignlayersdfs lce cc addtofnlist lce cc nexttokenstr level lce cc handleerror lce cc functionlookup lce cc illegal level crossing functionlookup level invoked findcallgraph level lce cc illegal level crossing functionlookup level invoked findcallgraph level lce cc illegal level crossing functionlookup level invoked assignlayers level lce cc illegal level crossing handleerror level invoked assignlayers level lce cc illegal level crossing functionlookup level invoked checklayers level lce cc illegal level crossing functionlookup level invoked checklayers level exiting errors cindy layered c lce r hw agrep c layered invokes structure exists satisfies input constraints note far lce tell following functions never invoked though may function pointers hw agrep utilities c subset pset hw agrep utilities c eq pset future work concrete conclusions drawn point usefulness tools yet used real software engineering project purpose paper however simply provide motivation tools support development layered systems describe author early attempts building tools several directions future work would beneficial important direction would actually try building non trivial size programs layered design using lcc real measure value tools attainable interesting possibilities future work include extend lcc include full c parser explore support layers languages particularly already provide support greater degree structure c explore ways grouping layer designations source code improve search capabilities lce look optimal layerings obtained simple depth first search references p d l parnas criteria used decomposing systems modules communications acm december p d l parnas designing software ease extension contraction ieee transactions software engineering se march mns gail c murphy david notkin kevin sullivan reflexion models bridging gap source high level models acm sigsoft software engineering notes october
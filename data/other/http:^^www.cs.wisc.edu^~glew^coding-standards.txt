date tue nov gmt server ncsa content type text html last modified thu sep gmt content length header u g l glew public html rcs coding standards html v glew exp p c coding standards p c coding standards december p architecture group r wilkinson history early drafts december january first release january second release december rev converted html glew thu jun introduction document details standards followed writing c code expected followed c programmers workgroup computing division portland promulgating standards hope address software issues related readability maintainability conforming common layout significantly easier members within group navigate within one another code adjust different coding formats remove significant impediment reading code others addition existence elements standard function headers aid others quite possibly authors understanding program since even simplest programs take lives recommended standards followed earliest point program inception relatively small overhead incurred initially repaid life program also noted code reviews intended part development methodology code expected conform standards pass review doubtful everyone agreement standards presented expected followed nonetheless cases good reasons exist standards document general intent within beyond context standards code easily readable understandable semi c literate programmer pertains format legibility c programs existence helpfulness comments within code well program order ordering sections within programs follows intel copyright notice rcs id declaration ltoverview gt overview file contents ltincludes gt file inclusions definition files h included ltdefines gt macro constant definitions typedef struct type structure definitions ltexterns gt external object definitions use caution ltglobals gt global variable declarations ltstatics gt static variable declarations ltforwards gt forward function declarations ltfunctions gt function declarations including main rcs log information discussed ltcopyright gt protect intel intellectual property every file copyright notice form copyright intel corporation year development represented ltrcs id gt rcs header information go beginning files form ifndef lint static char rcsid header u g l glew public html rcs coding standards html v glew exp endif case header files form header file called chapeau h ifndef lint static char rcsid chapeau h header u g l glew public html rcs coding standards html v glew exp endif ltoverview gt section block comment contain general overview file contents functionality file provide relate files part larger program major entry points etc appropriate questions answer ltincludes gt section contains include necessary header files ltdefines gt section contains necessary define typedef struct section contains typedef struct definitions specified file ltexterns gt section contains extern declarations specified file ltglobals gt section contains global variable declarations external visibility ltstatics gt section contains global variable declarations restricted static local visibility ltforwards gt section contains necessary forward function procedure declarations routines referenced actual implementation specified ltfunctions gt section contains body code routines including main placed ltrcs log gt rcs log information placed end files form log coding standards html v revision glew empty log message particularly cases extensive macro constant type structure definitions may effectively placed separate h file header files avoid potential problems caused nested header files body header files designed conditional inclusion format header file called toupee h given note required use leading trailing underscores ifndef toupee h define toupee h ltfile body gt endif toupee h irrespective format header files include variable declarations use facilities provided header file p system h strongly encouraged copy december included appendix file currently lives p arch src util names use capital letters names matter choice defines letters capitalized includes definitions constants macros elements enumerated type first letter capitalized letters lower case names consist entirely lower case letters use extraneous capital letters outside bounds specified require strong justifications names chosen reasonably descriptive underscores used separators names form getcacheindex getcacheindex acceptable lengthening name increases clarity understandability descriptive name chosen results longer names clearly re assuming bounds reason using j k indices statement pretty straightforward using five bits encoding register immediate value obvious insanity names avoided names might conflict standard library names names differ case e g foo foo foo names might look like e g x st x lst x one st x el st names override declarations higher level procedures names reflect function names reflect return functions returning true false values predicate form recommended e g queue empty ready queue ptr ford car strong encouragement given naming variables parameters pointers manner makes note quality suggestions black table ptr head p tailp filepp pointer pointer proc ad freaks recommended types variables routines stand good chance used outside file contained via include names prefixed string aid finding examples would btb popular branch target buffer entities dfa items data flow analyzer may experience wider audience macros macros provide convenient mechanism textual substitution result easy introduce subtle bugs undisciplined use macros interests avoiding problems following restrictions mandated macro routines elements passed explicitly parentheses around usage definition use local global variables within macros discouraged macros form define calc j j k l express violation standard appropriate form define calc j k l j k l macro consists multiple statements enclosed curly brackets ended semicolon interests avoiding potential side effects recommended macros written way evaluate parameters declaration standard section describes allowable forms declarations unless mentioned section forms declarations avoided function declarations described separate section emumerations proper forms typedef enum first second third type name form acceptable fits easily single line elements self explanatory typedef enum first pertinent comment required second pertinent comment required third pertinent comment required type name form used definition fit single line individual elements require explanation typedef enum first second third fourth fifth sixth seventh eighth ninth tenth eleventh twelfth thirteenth type name form used large numbers self descriptive elements typedef enum first initializer second initializer third initializer type name structures proper forms typedef struct type name field name purpose usage type name field name particularly long detailed explanation purpose usage field using remarkably long words referencing dull dry tomes better left buried crypt unearthed rather forced light day type name field name purpose usage type name typedef struct unsigned field name purpose usage unsigned field name purpose usage unsigned unused unsigned field name particularly long comment regarding purpose usage unsigned field name purpose usage type name course simple declarations type name id purpose usage type name id id type name id init id init case pointer declarations asterisk associated variable name pointer type illustrate following wrong int index ptr wrong rather proper form int index ptr right whether asterisk lined standard tab indentation level unindented one space matter programmer choice illustrate following acceptable bool ready int next widget unindented char id bool ready int next widget lined char id time fact compiler assigns enumeration values particular manner used program rather explicit values associated elements declaration use bit fields minimize storage usage opposed mapping hardware structures strongly discouraged unless truly obvious comments included element structure variable declarations one identifier line multiple identifiers multiple identifier assignments line acceptable unless intimately related even encouraged numerical constants coded directly instead define facility used constants declared explicitly long use capital l easy confuse letters digits rule followed e l el looks much like twenty one external arrays repeat array bounds declarations since given preceding paragraph fixed limit define ed problem maintainability never default int declarations whether functions parameters generous use keyword static global functions variables encouraged restrict visibility outside file global accessiblity variables discouraged without good reasons conversely use local extern declarations within functions actively discouraged without strong justification general poor idea employ local declarations override declarations higher levels particularly case structs types instances types combined declaration illustrate following acceptable struct windmill int num sails int usage int style quixote wrong rather struct windmill int num sails int usage int style struct windmill quixote right expressions said little one problems caused side effects parameters except avoid side effects expressions commendable words adhered rigorously remember operators also assignment operators thus produce side effects conditional expressions b c intuitive confusing particularly nested conditional expressions avoided appropriate approved form condition true return val false return val parentheses spaces around mandatory addition portion expression simple expression parentheses around offending section encouraged expressions span multiple lines split operator preferably lowest precedence operator near break using negation conditional expressions recommended expression operated upon enclosed parentheses improve readability remove ambiguities might arise use left shift right shift operators reserved bit operations use multiplication division exponentiation strongly discouraged besides intelligent compilers recognize arithmetic cases produce shift code anyway assignment statements initializations time place embedded assignment statements rarely general avoided primary acceptable instance conditional statements check special conditions two best examples obj ptr malloc elem num elem size null c getchar eof remember embedded assignment statement form side effect x x also assignment statements unless local variable going used shortly declared recommended initialization performed point first use rather declared global variables initialized declared convenient e g large arrays initialized dedicated initialization routine case dynamic initialization structure variables initialize fields order defined illustrate typedef struct int maker int model int year int color car car car car maker porsche car model expensive car year year car color red since live imperfect world assume uninitialized variables set zero compiler might case resist temptation succumb assumption initial value variable makes difference initialize explicitly along lines remember memory allocated malloc zeroed important dynamically allocated memory zeroed usually good idea calloc used respect dynamic memory allocations reader referred safer versions routines discussed p system header file appendix simple statements purpose ensuing discussions wish define mean simple statement simple statement one three possibilities either simple assignment x f x simple increment m m n function call f b c doubtful z f x f f y j n k r could considered simple statement conditional statements form conditional statements follows condition simple statement preferable condition statements else part condition simple statement else simple else statement condition statement else else statement complex conditions condition condition condition condition statements else else statements nested proper form condition statements else condition statements else condition statements else statements nested control structures including nested statements compound statements required illustrate following allowed condition condition statements else else statement wrong rather approved form condition condition statements else else statement right use compound statements recommended avoid ambiguity following acceptable condition condition simple statement wrong else simple else statement better use either condition condition simple statement else simple else statement condition condition simple statement else simple else statement depending upon intended time brackets required parts conditional statement parts conditional statement simple statements defined simple statements section words part conditional statement compound statement whatever reason parts must compound general use compound statements encouraged aid readability maintainability iterative statements iterative statements form condition statements statements condition initial condition next statements infinite loops recommended form true true defined nonzero statements statements single simple statement executed brackets required encouraged event statement executed must line iterative statement null empty body use empty compound statement containing comment verifying emptiness find strings differ str str void use continue statement encouraged used commented explicitly possible used early loop body addition appropriate comments added make easy determine target compound bracketed statements mentioned earlier requirement use brackets iterative statements single simple statement executed said true conditional statements added proviso statement conditional statement compound statements required compound cases although brackets required strongly recommended aid maintainability illustrate consider following calculation ackermann function values x x later decide sum values go along might unwittingly add x x sum new code although indentation might make look right sum calculated loop would end value ackermann limit know better something stupid like occurrence others course frequent thus recommended form initial construct x x removes possibility ambiguity reduces chance error later enhancements modifications switch statements switch statements following form switch selector case first case second statements break case third statements break case dont care case dont care break default fatal unexpected selector procedure name switch statements departure standard indentation mentioned indentation spacing section standard indentation spaces one space tab stop switch statements case indented spaces switch statements indented spaces one tab switch last case statement followed explicit break even last choice statement prevents potential oversight problems switch statement added later time last choice switch statement default require break case enumerated types element enumeration must case switch statement addition default must exist last choice must contain indication error occurred statements particular case end break thereby continuing control following case bold comment exist indicate explain situation addition recommended lint style comment form fallthrough placed break might otherwise illustrate print numeric value switch num type case signed int putchar num negative place sign fallthrough case unsigned int printf d num int value print value break case floating pt printf lf num fp value break default warning unknown num type encountered function standard proper form function declaration follows function name function interface specification purpose routine expected usage pertinent comments regarding return values params discussion parameters assumptions made parameters section necessary something meaningful said parameters contained comments logic internal operation structure algorithm description assumptions assumptions made affect correct functioning routine note special caveats concerns special cautions returns information regarding possible return values return type function name param param param type param purpose expected values param type param modified purpose expected values type variable purpose variable description use variable second type purpose description second variable much detail necessary make sense others type variable comment code body end function name portions function comment header may omitted meaningful content minimum necessities function name function sections function parameter must declared separate line declarations multiple parameters type line expressly forbidden matter intimately related parameters may although c assumes function without specified type returns int construct never used functions either explicit return type void return value function specified void never used expression function specified explicit return type never used statement returned value interest recommended cast form void f x dont care f x indentation spacing specific exceptions mentioned earlier section switch statements standard unit indentation space tab spaces use tabs encouraged tab stops must without exception spaces due idiosyncrasies text formatters tabs spaces may translated paper accurately examples document assume indentation levels spaces appears intent every reasonable effort made limit line lengths characters improves readability looking listings viewing standard limited alpha numeric terminals program understandability compromised meet goal code consistently breaks column barrier may need justified higher court one primary purposes spaces program enhance readability end use horizontal vertical spacing encouraged aid uncertain reader following recommendations provided least three blank lines routines one space comma spaces around assignment operators etc one space either side binary operator except spaces identifier space function name left paren extraneous spaces end line comments comments vital necessary aid program understanding one expressed goals strongly encouraged noted insistence comments code much help original developer though may prove useful regard support others may become involved code later date whether next week next month next year someone potentially less brilliant need understand code without benefit developer assistance audience towards comments directed comments form especially encouraged whenever closing delimiter line opener must lined opener addition comments form expressly forbidden comments refer code follows comment indentation level code follows comments directly refer code preceding comments indented one level indentation level preceding code illustrate get next free index index get free index x ptr returns either free index zero none addition normal good sense commenting offensive code justified profuse comments aids readability comprehension organization comment banners acceptable code review committee permitted though required popular choices attached approach include function declarations variable declarations globals l control l helpful formatting output causes page feed subsequent text starts top new page used l line time considered acceptable substitute l blank lines functions miscellaneous aid promoting good programming practice use notorious goto setjmp longjmp outlawed order employ construct must conclusively proven otherwise results impossibly convoluted code pointer arithmetic potentially dangerous used care goes without saying c permits wide latitude pointer operations however fact language provides means hang oneself necessarily mean thing code far readable maintainable constructs avoided true usage form c char ptr may reasonable usage form c char ptr char ptr bad idea best rather risk needless obfuscation recommended simplest pointer arithmetic avoided possible use necessary presence explanatory comments strongly advocated pointers compared null header file stdio h rather code depends upon order evaluation expressions acceptable examples things b bad x f bad come province side effects avoided discussed section expressions cases code written readable understandable possible someone moderate understanding c programming reasonable understanding program question subtleties c necessary commented clearly readily understandable c programmer particularly involved complex code required comments copiously strewn promote better understanding time code written whose correct understanding depends upon detailed knowledge workings particular compiler certain character strings reserved use certain conditions serve flags alert us circumstances may require special attention reserved strings expected used comments indicate particular situations description usage follows tbd flag used indicate items require later definition stands defined determined ensuing comment provide particulars nyi flag used indicate items defined awaiting implementation stands yet implemented ensuing comment provide particulars machdep flag used indicate existence explicit machine dependency code ensuing comment provide particulars bug flag used indicate existence bug form followed immediately comment line one keywords incomplete untested wrong indicate type along descriptive comment appropriate none keywords applicable descriptive word used along extensive comment machine dependent code avoided much possible absolutely necessary localized routines separate file possible cases extensive comments order day use conditional compilation facilities discouraged wherever possible necessary recommended localized header files separate machine dependent code file structure overlays casting one structure pointer type different structure pointer type avoided costs rare cases absolutely necessary advised localized separate machine dependent file copious comments avoid use unnecessary global variables include ing name c files code files strongly discouraged disagreements arise code review committee final word extent code readable understandable request code review member useful comments evidence comments necessary anyone responsible coding manner odds standards assumption one reading code b never go code review whatever reasons c care suspended toes shot dawn use indent possible use program indent provide formatting file roughly conforms coding standards incompatible differences accomplish run indent file npro nip nfc cli c save old version file file bak place newly formatted version file specify explicit file file unfortunately handle formatting comments correctly cases specific comments form boring comment goes beyond end line length get reformatted boring comment goes beyond end line length direct violation comment standard means running indent file still necessary go file edit ensure conforms coding standards use lint important remember c takes point view programmers know re luckily programmers tools developed aid helping ensure intended one useful tools along lines lint lint command checks c code coding syntax errors inefficient non portable code includes things detection unused potential problems variables functions type mismatches possible errors flow control legal constructions may intended details lint operation differ machine machine reader referred man page lint particulars command example following example intended demonstrate standards cache hit function routine determines whether memory reference cache hit index p changed refer appropriate element cache true returned index p modified refer element cache replaced false returned logic appropriate cache selected based upon type cache cache searched determine address question mem addr present cache index one return caller via index p cache index returned user potential modification determined based upon cache type assumptions assumes selected cache configured note special circumstances cautions direct mapped fully associative caches currently supported unspecified results returned unsupported cache type specified returns true element cache false element cache bool cache hit mem addr index p selector knobs mo addr mem addr memory address int index p pointer cache index hit replacement int selector selects cache question instruction data knobs knobs system configuration parameters constraints ptr int index used local index computations dfa cache elem cache cache pointer select cache used cache dfa cache selector direct cache pointer first element desired cache simply reference using cache determine cache type operate accordingly switch knobs cache type selector case direct map index mem addr cache index mask selector cache index valid cache index tab mem addr hit index p index return true else miss index p index return false break case associative case fully associative step cache looking match index index cache size selector index cache index valid cache index tab mem addr hit index p index return true match found miss find free index index p get lru index selector knobs return false break case set associative case set associative case set associative debug warning unimplemented cache type cache hit break default fatal unexpected default cache hit end cache hit appendix p system header file following listing p system h header file december accurate rendition file reader referred p arch include current copy available copyright intel corporation ifndef lint static char rcsid p system h header u g l glew public html rcs coding standards html v glew exp endif p arch include p system h p standard c header file file contains definitions useful c programming throughout p project recommended use definition declaration given documented respected improve readability c code e use something contained herein way documented tend obscure code p members ifndef p system h define p system h standard truth values realize c declares non zero values true never write code like true recommended code would instead simply read direct comparison false acceptable though false conveys intended meaning doesn got yas comparisons true also try conscience different false null false denotes boolean value whereas null pointer value compare pointers false use null instead similarly use false re testing boolean ifndef true define true endif ifndef false define false endif standard boolean type although c little concept actual boolean type true false variables fact booleans best indicated use type end type provided typedef int bool ansi c compatible function prototyping ansi c compilers perform type checking arguments passed functions function prototype function provided presumably header file unfortunately k r c compilers e olders ones consider ansi function prototypes syntax errors macro designed deal currently c compilers understand function prototypes available rs xlc c suns vaxes gcc ansi c prototypes k r declaration libc function strncpy follow ansi c function prototype extern char strncpy char char unsigned alternate ansi c function prototype extern char strncpy char dst char src unsigned max length k r function prototype extern char strncpy ansi c compilers accept three syntaxes second considered descriptive prototype use encouraged problem k r compilers still exist want able compile programs macro give uses ansi c declared preprocessor symbol stdc detect whether compiler understand function prototypes stdc declared prototype omitted example use macro given usage recommended declaration libc strncpy extern char strncpy args char dst char src unsigned max length notice double set parentheses required stdc defined done automatically ansi c compilers expands extern char strncpy char dst char src unsigned max length otherwise expands extern char strncpy gives us functionality want given ansi c compiler get argument type checking code still work older k r compilers ifndef args ifdef stdc define args x x else define args x endif endif args assertions common useful programming practice add assertions code events either unexpected unhandled current code trapped rather quietly creating bugs along line p code use following macro coding assertions thus allowing single uniform mechanism unfortunately nearly every machine implements version assertions thus necessitating us use get uniform interface p assertions coded follows usage foo never greater assert foo stdio h define debug include p system h undef debugf define debugf stdout debugf outputs messages conditional another preprocessor symbol debugf cond able turn debugging messages runtime define debug include p system h undef debugf cond int debugvar defaults debugging messages define debugf cond debugvar debugging output conditional variable debugvar macro omitdebugf similar omitassert expands nothing making easy comment debug message giving credit credit due nearly ideas stolen directly andy glew standard debug h file ifdef debug define debugf args debugf cond p assert setup debugf file line p assert args else debug define debugf args endif debug define debugf define debugf cond define omitdebugf args standard safe versions malloc realloc calloc typically programmers either clutter code checks null return value every call malloc omit checks altogether routines available p library used general replacements malloc family routines null guarantee return valid pointer amount memory requested underlying malloc etc actually failed return memory e returned null routines exit message stderr explaining situation via assert rather returning functions defined p arch lib p hosttype libp library linked cc command line arguments l p arch lib p hosttype lp using routines simply eliminates error checking programmer code thus improving readability extern char xmalloc args unsigned size extern char xrealloc args char pointer unsigned size extern char xcalloc args unsigned nelem unsigned elsize endif ifndef p system h
mime version server cern date tuesday jan gmt content type text html content length last modified friday jun gmt oops group publications oops group publications sheetal v kakkad mark johnstone paul r wilson portable runtime type description conventional compilers submitted usenix many useful language extensions support libraries require knowledge layout fields within objects runtime examples include orthogonal persistent object stores garbage collectors data structure picklers parameter marshalling schemes etc clean efficient implementation libraries systems require knowledge actual layouts data objects unavailable traditionally compiled linked programming languages c c ada present facility runtime type description rttd extracts low level layout information debug output conventional compilers makes available user programs describe basic strategies system present details interface c also sketch extensions implemented including special treatment c virtual function table pointers implementation freely available via anonymous ftp postscript kb michael neely analysis effects memory allocation policy storage fragmentation master thesis university texas austin may study dynamic memory allocation dominated measurement performance allocators random input streams requests study introduces new methodology separates issue policy implementation focuses effects placement policy fragmentation studies effects policy decisions object placement splitting coalescing storage fragmentation useful accurate measurement fragmentation presented based amount waste point peak memory usage attempted pick representative set allocators space reasonable combinations known policies allocators used memory allocation simulations determine respective fragmentation results show best fit fifo lifo address ordered address ordered first fit policies yield lowest fragmentation average overheads associated allocators largest source wasted memory also explain best fit implemented efficiently representative set real program allocation traces used simulations compared randomized traces show application patterns allocation important factor allocator performance studies based synthetic traces fundamentally flawed compressed postscript kb paul r wilson mark johnstone michael neely david boles dynamic storage allocation survey critical review international workshop memory management kinross scotland uk september dynamic memory allocation fundamental part computer systems since roughly memory allocation widely considered either solved problem insoluble one survey describe variety memory allocator designs point issues relevant design evaluation chronologically survey literature allocators scores papers discussed varying detail references given argue allocator designs unduly restricted emphasis mechanism rather policy latter important higher level strategic issues still important given much attention theoretical analyses empirical allocator evaluations date relied strong assumptions randomness independence real program behavior exhibits important regularities must exploited allocators perform well practice postscript kb paul r wilson sheetal kakkad shubhendu mukherjee anomalies adaptation analysis development prefetching policies journal systems software november technical communication analysis development demand prepaging policies horspool huberman show possible design prefetching memory policies preserve stack inclusion property much like lru allowing simulate policies sizes memory single pass reference trace believe details horspool huberman algorithms introduce unexpected anomalous properties however particular policies properly timescale relative events occuring timescale matter sizes memory adversely affect replacement decisions memories different sizes slight changes algorithms restore timescale relativity make much better behaved addition would like point horspool huberman algorithms actually simulate adaptive policies may explain unexpectedly positive results view suggests properly timescale relative inclusion preserving policies used systematically evaluate adaptive memory management schemes postscript kb paul r wilson mark johnstone real time non copying garbage collection position paper acm oopsla workshop memory management garbage collection washington d c september postscript kb paul r wilson uniprocessor garbage collection techniques international workshop memory management st malo france september proceedings published springer verlag lecture notes computer science survey basic garbage collection algorithms variations incremental generational collection basic algorithms include reference counting mark sweep mark compact copying treadmill collection incremental techniques keep garbage collection pause times short interleaving small amounts collection work program execution generational schemes improve efficiency locality garbage collecting smaller area often exploiting typical lifetime characteristics avoid undue overhead long lived objects postscript kb paul r wilson uniprocessor garbage collection techniques draft much expanded version paper revision accepted acm computing surveys survery basic garbage collection algorithms variations incremental generational collection discuss low level implementation considerations relationships storage management systems languages compilers throughout attempt present unified view based abstract traversal strategies addressing issues conservatism opportunism immediacy reclamation also point variety implemetation details likely significant impact performance postscript kb paul r wilson sheetal v kakkad pointer swizzling page fault time efficiently compatibly supporting huge address spaces standard hardware international workshop object orientation operating systems pages paris france september pointer swizzling page fault time novel address translation mechanism exploits conventional address translation hardware support huge address spaces efficiently without long hardware addresses large address spaces attractive persistent object stores distributed shared memories shared address space operating systems swizzling scheme used provide data compatibility across machines different word sizes even provide binary code compatibility across machines different hardware address sizes pointers translated swizzled long format shorter hardware supported format page fault time extra hardware required continual software overhead incurred presence checks indirection pointers pagewise technique exploits temporal spatial locality much way normal virtual memory gives many desirable performance characteristics especially given trend toward larger main memories easy implement using common compilers operating systems postscript kb vivek singhal sheetal kakkad paul wilson texas efficient portable persistent store persistent object systems proceedings fifth international workshop persistent object systems pages san miniato italy september texas persistent storage system c providing high performance emphasizing simplicity modularity portability key component design use pointer swizzling page fault time exploits existing virtual memory features implement large address spaces efficiently stock hardware little change existing compilers long pointers used implement enormous address space transparently converted hardware supported pointer format pages loaded virtual memory runtime type descriptors slightly modified heap allocation routines support pagewise pointer swizzling allowing objects pointer fields identified within pages compiler support runtime type identification available simple preprocessor used generate type descriptors address translation largely independent issues data caching sharing checkpointing employs operating systems existing virtual memories caching simple flexible log structured storage manager improve checkpointing performance pagewise virtual memory protections also used detect writes logging purposes without requiring changes compiled code may degrade checkpointing performance small transactions poor locality writes page diffing sub page logging promise keep performance competitive finer grained checkpointing schemes texas presents simple programming interface application creates persistent object simply allocating persistent heap addition implementation relatively small easy incorporate existing applications log structured storage module easily supports advanced extensions compressed storage versioning adaptive reorganization postscript kb paul r wilson michael lam thomas g moher caching considerations generational garbage collection acm symposium lisp functional programming san francisco california june postscript kb papers bibliography heap management source code texas persistent store available via anonymous ftp ftp cs utexas edu pub garbage readme file lists available material including subdirectories contain collected papers oopsla garbage collection memory management workshops sheetal v kakkad
date tue nov gmt server ncsa content type text html last modified wed aug gmt content length lecture notes chapter exception handling chapter exception handling exception handlers trouble programmed o wastes cpu resources potential incorrect operation really want since o devices slow o devices signal cpu change status o devices tell cpu ready order need hardware wires devices cpu way special software invoked device signals wire modern solution bundles software deal signals interrupts situations exception handler effectively part os exceptions interrupts initiated outside instruction stream arrive asynchronously specific time examples o device status change o device error condition thermal override shutdown internal error detection interrupt dealt soon possible traps occur due something instruction stream arrive synchronously instruction executing good test program re run trap would occur precisely place code examples unaligned address error arithmetic overflow syscall trap dealt right user program cannot continue whatever caused trap dealt exception handling mechanism dealing exceptions simple implementation get complex implementation varies among computers manufactures situation user program running executing device generates interrupt request mechanism respond hardware temporarily suspends user program instead runs code called exception handler handler finished whatever needs hardware returns control user program limitations exception handler since invoked potentially middle user program handler must take extra care change state user program change register values change stack anything key answer portion state change must also restore returning user program handler often uses system stack temporarily store register values handle interrupt possiblilities right note could middle instruction order hardware must able know instruction execution able take left difficult done simpler forms machines example arbitrary memory memory copy wait currently executing instruction finishes handle method choice instruction fetch execute cycle must expanded handle pending interrupts instruction fetch pc update decode operand load operation store results terms interrupt request activation hardware somewhere signals initial request interrupt pending interrupt interrupt hasn handled yet needs kernel exception handler minds people think kernel think critical portions operating system exception handler critical portion operating system handler code exception handler mips exception handling mechanism hardware following sets state giving cause exception cause register coprocessor c register bit register bits bits specify type exception called exccode page text gives mapping encodings causes examples interrupt load illegal address syscall instruction arithmetic overflow changes kernel mode saving previous mode hardware stack levels deep mode saved status register coprocessor c register defined processor architecture modes user mode user programs run certain instructions available kernel operating system mode allows os retain control vital system aspects instructions available disables interrupts saves current pc coprocessor c register called exception program counter gives return address user program return done handling exception jumps hardwired address x exception handler code code within exception handler run following save registers system stack handler needs use registers may change clobber register contents user program saves stack memory figure exception type exccode mfc k get cause register andi k k x c mask exccode use exccode combination jump table jump correct location within exception handler handle exception whatever restore registers saved atomically done step restore previous kernel user mode status register reenable interrupts jump back user program using epc jump tables clever mechanism something like case switch statement jump one many locations keep table addresses case case case jumptable word case word case word case sll case number shifted left bits need word offset table byte lw jumptable load address jr jump address contained case code case case code case case code case note cases go specific order addressing mode label rb effective address gotten label rb label doesn fit bit displacement field load store instruction mal tal synthesis must something like la label add rb use addressing mode load store instruction advanced topics priorities problem multiple interrupt requests arrive simultaneously one get handled first possible solutions fcfs first one arrive gets handled first difficulty might allow malicious recalcitrant device program gain control processor difficulty must hardware maintains ordering pending exceptions prioritize exceptions one highest priority gets handled first common method solving problem priorities various exceptions assigned either manufacturer system manager software priorities normally set machine booted os started difficulty exceptions priority must still handled order example priority exceptions might keyboard interrupts consider machine many terminals hooked instruction fetch execute cycle becomes interrupts higher priority whatever currently running pending fetch decode operands operation result note implies hardware notion priority whatever running user program keyboard interrupts clock interrupt etc get given highest priority clock power failure thermal shutdown arithmetic overflow keyboard o device ready priorities matter urgent therefore cannot wait long takes process interrupt clock urgent takes little processing maybe variable increment power failure urgent takes lot processing machine stopped overflow urgent program caused cannot continue keyboard urgent want lose second key press first handled story happen interrupt priorities set wrong reentrant exception handlers best solution combines priorities exception handler interrupted many details get right make possible instruction fetch execute cycle remains beginning every instruction even within exception handler check made pending interrupts higher priorities whatever currently running processed exception handler must modified interrupted state must saved safely within handler disable interrupts momentarily order save important state cannot get clobbered epc current priority level maybe registers question things get saved re enable interrupts higher priorities current level priority level checking done hardware interrupts re enabled invocation exception handler eventually finishes instruction fetch execute cycle must expanded handle pending interrupts instruction fetch pc update decode operand load operation store results
introduction scheme implementation table contents introduction scheme implementation overview scheme small powerful language book scheme scheme book structure book introduction scheme hunk basic scheme features code consists expressions parenthesized prefix expressions expressions return values may side effects defining variables procedures operators procedures definitions vs assignments special forms control structures expressions boolean values f control flow constructs cond cond comments hunk c note parentheses indenting let editor help indenting procedure calls simple control constructs indenting cond indenting procedure definitions values pointers objects values pointers implementations optimize away pointers objects heap scheme reclaims memory automatically objects types variables dynamic typing empty list hunk e pairs lists cdr linked lists lists quoting empty list got name recursion lists data structures type equality predicates hunk g type predicates equality predicates choosing equality predicates hunk quoting literals simple literals self evaluation local variables lexical scope let indenting let expressions lexical scope binding environments binding contours block structure diagrams lets let procedures hunk k procedures first class higher order procedures anonymous procedures lambda lambda lexical scope hunk m local definitions recursive local procedures letrec multiple defines like letrec variable arity procedures take variable number arguments apply variable binding identifiers variables variables vs bindings vs values tail recursion hunk o macros continuations iteration constructs discussion review using scheme tutorial interactive programming environment hunk b starting scheme making mistakes recovering returns parentheses interrupting scheme exiting quitting scheme trying expressions booleans conditionals sequencing flow control structures using cond using making objects hunk d lists hunk f using predicates hunk h using type predicates using equality predicates local variables let lexical scope hunk j using first class higher order anonymous procedures hunk l first class procedures using writing higher order procedures interactively changing program hunk n replacing procedure values loading code file loading running whole programs useful data types strings symbols note identifiers lists heterogeneous lists operations lists basic programming examples hunk p error signaling routine length copying lists append reverse append reverse map map member assoc friends member memq memv assoc assq assv procedural abstraction procedure specialization procedure composition currying discussion review writing interpreter interpretation compilation implementing simple interpreter read eval print loop reader implementing read implementing read list comments reader recursive evaluation note snarfing bootstrapping snarfing bootstrapping cross compiling improving simple interpreter discussion review environments procedures understanding let lambda let lambda define lambda currying procedures closures lambda cheap closures fast interpreter let lambda nested environments recursive evaluation integrated extensible treatment special forms interpreting let variable references set interpreting lambda procedure calling mutual recursion eval apply variants let letrec let understanding letrec using letrec lambda implement modules let iteration constructs named let programming procedures environments exercises recursion scheme subproblems reductions non tail tail calls continuation chain exploiting tail recursion passing intermediate values arguments summing list implementing length tail recursively reduce quasiquotation macros quasiquote unquote splicing defining new special forms macros vs procedures implementing scheme special forms let let cond discussion lisp style macros ultra simple lispish macros better lisp style macros problems lisp style macros ugly hacks around name conflicts implementing simple macros quasiquote implementing simple macros implementing quasiquote unquote translating backquotes quasiquote quasiquote define rewriter define macro procedural macros vs template filling macros programming examples using macros records object orientation records data abstraction implementing records objects object orientation implementing simple object system generic functions dynamic dispatch inheritance useful features special forms input output facilities read write display ports input dots forms useful types associated procedures numeric types floating point numbers arbitrary precision integers ratios coercions exactness vectors strings characters call current continuation implementing better read eval print loop implementing catch throw implementing backtracking implementing coroutines implementing cooperative multitasking caveats call current continuation simple scheme compiler compiler interpreter ok compiler compiler generate basic structure compiler data representations calling convention etc registers evaluation stack eval stack short continuation chain environments closure representation calling continuations applying procedure doesn save caller state continuation saving example generating unique labels representations environments compiling code literals compiling code top level variable references precomputing local variable lookups using lexical scope lexical addressing compile time environments detailed example preserving tail recursiveness using compile time continuations save continuations compiling returns compiling top level expressions compiling lambda expressions inside procedures compiling top level definitions interfacing runtime system garbage collection safe points gc time interrupts advanced compiler runtime system techniques inlining small procedures type declarations type analysis using hardware registers closure analysis register allocating loop variables loops conventional optimizations stack caches concept index document generated october using texi html translator version
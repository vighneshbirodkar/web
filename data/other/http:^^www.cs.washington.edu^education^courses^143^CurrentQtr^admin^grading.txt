date mon dec gmt server ncsa content type text html cse grading policy cse grading policy grading policy cse based two main factors functionality well program works software engineering well program constructed functionality main goal programming create working program however working generally extremely vague term since depends program supposed many cases programs assign underspecified won tell exactly work instead ll give pretty good idea expect leaving decisions handle tricky ambiguous cases way ll turn partial specification exact specification example partial specification might ask write program draws mazes screen without telling exactly input get user kind maze make might decide draw rectangular mazes ascii characters prompt user maze size terms characters see addition might detail way maze constructed making decisions ve created exact specification something explains precisely program run big would like maze rows x columns x maze start end although rarely single correct way handle ambiguities partial specification sure full specification spirit partial specification example writing program always generated mazes following form probably isn mind long would like maze columns maze start end bottom line order know program working decide supposed therefore first step define full specification ll generally asked submit full specification program comments cover sheet example know specific goals choices long document short clear description program expected behavior highlighting handles ambiguous cases means feel free discuss specification choices tas ve finished writing program demonstrate us works running test cases generally ll supply test cases test aspects program program works test cases doesn necessarily mean correct re done make sure write test cases check ambiguous cases full specification describes use demonstrate us program works specified software engineering software engineering program put together involves division program separate logical modules defining reasonable interfaces modules commenting code clear others like ta remember based stereo analogy programs re looking built multiple modules interacting clean well defined interfaces re looking single monolithic piece code everything thrown without sense order technique might benefits stereo world rarely software extent graded well program constructed addition well works comment clear design make reasonable decisions code organized interface modules etc things may seem like pain may seem less important getting program working essential programming environment whether group project course huge microsoft application programs grow larger evolve time initial structure often determine easy maintain debug improve backwards seems program well structured documented doesn quite work comment reading think problem somewhere routine often impressive one works completely indecipherable strive best questions still unclear re looking please consult ta cse webmaster cs washington edu
mime version server cern date sunday dec gmt content type text html content length last modified saturday may gmt improved version parallel object tracker rivl improved version parallel object tracker rivl http www cs cornell edu info people barber potrivl potrivl html sicco tans stans cs cornell edu jonathan barber barber cs cornell edu cs final project professor ramin zabih department computer science cornell university table contents abstract introduction rivl generic parallel paradigm rivl graph generic parallel rivl rivl object tracker object tracker script algorithm behind im search parallelizing im search problems im search generic parallel rivl parallelizing im search rivl course grain parallelization scheme implementation inefficient parallel im search implementation persisent parallel object tracker passing sequence information contents shared memory setting shared memory updating shared memory new semaphore implementation issues performance results extensions improvements conclusions references go back abstract fields multimedia image processing computer vision converging time lot work spent making image vision processing algorithms efficient accessible usable programmers strong example merging technologies exists rivl object tracker focus work paper detail inception development efficient parallel object tracker available rivl go back introduction many similarities fields multimedia image processing computer vision many instances hard distinguish one fields involve operating single continuous stream images operations typically incur large computational expense object tracking example multimedia vision application recent years lot effort spent attempting make image processing vision related algorithms easier program adding many layers abstraction image data image operations interface programmer user time higher levels abstraction add computational complexity operation left researchers developers extraordinarily difficult problem making multimedia vision operations fast efficient easy use effort manifested construction rivl resolution independent video language rivl multimedia software processing package given set images set sequence images efficiently process multimedia streams generate outgoing image sequence images rivl implemented tcl extension capable performing common image operations overlay smoothing clipping cropping etc also includes complex vision related image processing operations object tracking focus work tcl interface simplifies process coding image vision processing script recent months several developers improved rivl performance measures via fine grained parallelization scheme using shared memory machine distributed computing environment parallelization independent image operations resident rivl library e g im clip im smooth im canny unfortunately scheme lend complicated computer vision applications particular scheme work object tracking bearing mind established project goal develop backwards compatible parallel implementation object tracking tailored rivl section introduce rivl describe generic parallelization scheme section describe hausdorff based object tracking algorithm implemented rivl section introduce scheme parallelizing rivl object tracking operation section describe implementation parallel object tracking rivl operation section present performance results section present extensions future work improvements current implementation section draw conclusions go back rivl generic parallel paradigm go back rivl graph begin discussion rivl introducing rivl evaluation graph order rivl execute requires set multimedia input data control rivl script rivl script sequence tcl rivl commands specify image processing operations occur input data rivl invoked rivl script translated rivl graph pictured node corresponds image operator e g im smooth im canny etc edge signal corresponds actual image data nodes lying inside illustrated rectangle correspond true image operators nodes lying outside rectangle rivl o nodes nodes outside left rectangle correspond read nodes e one read node per image stream node right rectangle corresponds write node want emphasize construction rivl graph compute multimedia data rivl graph merely control flow structure inputted sequence data must propagate generate outputted processed image two phases processing data using rivl graph constructed first phase manifests graph traversal right left makes rivl efficient image processing mechanism first node evaluated write node right node traversing graph reverse order rivl decides node exactly much data output signal requires input signal evaluation reverse propagated write node graph back every read node reverse propagation completes every node graph knows exactly much data input signal required compute node corresponding output signal multimedia data processed second traversal conforms left right traversal rivl graph propagating input data forwards graph operating data relevant final output image go back generic parallel rivl summarize preceding section statement amount data fetched read node exactly function output write node combining notion fact image processing operations rivl create dependencies one pixel another given input image derive simple mechanism dividing work parallelizing rivl instead running rivl single processor rivl spawns multiple processes different processors process work towards computing different segment output data define notion single master rivl process multiple slave rivl processes slave process run different processor started slave process sits idle listening instructions master initial setup period master sends slave process logical id addition slave aware total number processes available work following control setup period master sends slave copy rivl script slave master receives rivl script generate copy rivl graph perform right left traversal independently difference right left traversal logical id current processor total number processes becomes factor determining much computation gets done process according figure amount data fetched read node longer function output write node function process logical id total number processes function write node output rivl process responsible computing different independent portion final output data based parameters approach fine grained rivl process performs set computations different data actual data computation left right graph traversal occurs master says go slave master process computes appropriated portion output image go back rivl object tracker go back object tracker script rivl object tracker implemented tcl script executes set rivl image operations given image sequence model look job rivl object tracker determine object model resides given image frame sequence images image sequence represented rivl datatype e g mpeg continuous jpeg model string points bounding box specifying location object given image tracker operates follows looks adjacent images sequence define prev previous next want determine object model went prev next every adjacent set images tracker performs following sequence operations first smooths using rivl im smooth operation edge detects using im canny operator canny edge detector next prev smoothed edge detected previous iteration im search command invoked actually performs object tracking im search command extracts actual object tracked prev specified model im search searches instance object next im search completes returns new bounding box model corresponds location tracked object next modifying rivl script generate output sequence images illustrates object tracked sequence images illustrates output rivl object tracker tracked object appears highlighted rest image dimmed go back algorithm behind im search search based hausdorff distance measure similarity two different sets points im search command compares object different locations inside next find hausdorff distance d within threshold value v match found one d found within v pick match smallest di corresponding best possible match search utilizes multi resolution approach image next evenly divided separate regions region pre searched determine anything interesting region interesting mean substantial clustering edges within threshold u region determined interesting recursively sub divided pre searched recursively dividing image locating interesting regions overall search space decreased hausdorff distance comparisons model region interests proceed reduced search space go back parallelizing im search multi resolution approach lends parallelization level resolution separate independent regions must pre searched pre searches processed parallel hungry puppy fashion pre search recursively moves lower level region sub divided pre searched searches also done parallel forth go back problems im search generic parallel rivl mentioned introduction generic parallel scheme described earlier works majority image operations rivl unfortunately case im search generic parallel rivl output write region sub divided based process logical id total number processes willing work paradigm process responsible portion output region computation output region rely upon output regions generic rivl communication different processes given traversal rivl graph process independent one another unlike general operations output region im search cannot simply sub divided different regions computed independently one another true reason object tracked may overlap several write regions since communication processes given traversal rivl graph im search work using generic rivl go back parallelizing im search rivl go back course grain parallelization scheme section introduced method parallelizing im search based multi resolution approach object tracking exactly scheme implemented rivl unfortunately scheme currently incompatible fine grain generic parallel rivl reasons described rather parallel im search implemented original sequential version rivl alternative parallelization scheme works follows rivl initially invoked one process master process master constructs rivl graph performs right left traversal im search like image operation constructed rivl node image sequence tracked loaded ready image makes left right traversal rivl graph data encounters im search node following sequence events happens rivl spawns n slave processes extension im search master process organizes multi resolution pre searches maintains high priority queue low priority queue high priority queue contains list pre searches sub divided image slave process pulls jobs queue performs pre search job interesting region found slave process sub divide region smaller regions place sub divided region job onto low priority queue master write high priority queue read low priority queue slave read high priority queue write low priority queue essentially slave process performs pre searches hungry puppy fashion narrow scope overall search region master process responsible maintaining queues initially places work onto high priority queue slaves fetch clears new pre search jobs specified slave process low priority queue places back onto high priority queue next level recursion pre searches concluded slaves fulfilled tasks current iteration master computes hausdorff distances object interesting regions looks best possible match one found outputs new bounding box object based current image next go back implementation inefficient parallel im search discovered implementation parallelized im search rivl node unfortunately unable give credit developer implementation completely un documented implementation utilizes parallelization scheme described previous section design meant run shared memory machine left right traversal rivl graph hits im search node rivl attaches high low priority job queue data structure shared memory generates unix ipc semaphores govern access shared object prevent race conditions synchronize parallelization shared memory semaphores set rivl forks n slave processes want emphasize implementation spmd shared data job queue simply data structure contains pointers different portions next object model image data completely replicated rivl process reside exactly address process address space parallel computation proceeds described slave processes done e interesting regions found master kills slave de allocates shared memory segment master proceeds finish object tracking computation next traversal rivl graph sequence events repeated master sets shared memory semaphores re forks re kills slaves believe wasteful implementation im search every iteration expensive unix kernel system calls generated setup shared memory semaphores expensive resources wasted re allocating memory segment fork n slave processes involves replicating im search node entire rivl address space includes replicating rivl graph rivl data including model image data believe developers implementation forked new slaves every iteration eliminate lot work complications involved establishing efficient means communication processes wastefulness led us develop smarter implementation im search re uses resources improves performance object tracker go back implementation persistent parallel im search improved way implementing object tracking algorithm seeks reduce overhead re creating shared memory segment forking series child processes frame object tracking sequence little information position current frame larger tracking problem object tracker keep shared memory child processes alive sequence images continue tracked way master process simply put new image model shared memory wake children start work current tracking sub problem sequence completely tracked shared memory cleaned children killed anticipation new sequence tracked go back passing sequence information first issue dealt passing sequence information object tracker required information rivl tcl interface c procedures basic idea figure many images sequence tracked index current frame processed frame first frame sequence object tracker ran mp startup procedure set shared memory segment large enough current image sequence forked child processes current frame last frame sequence object tracker would run mp shutdown remove shared memory segment clean child processes completing tracking algorithm frame position meant frame somewhere middle sequence required special action go back contents shared memory master process responsible keeping shared memory segment date current tracking task child processes longer contain recent image model information structures explicitly maintained shared memory basically shared memory extended rudimentary object tracker contain large body additional data addition basic jobs structure outlined points current model points current image distance transforms current image various levels scaling associated image structures go back setting shared memory shared memory basically set contain various data structures one big contiguous block certain parts data constant length throughout image sequences points model image particular varied length requiring assumptions maximum number points might expected present remaining structures particular image distance transforms consistent size dependent size images sequence words knowing size first image sequence enables single allocation sufficient entire sequence course dependence size images sequence reason particular shared memory segment kept around one sequence images making assumptions maximum size sequence would enable shared memory segments child processes stay around multiple sequences tracked make extension diagram illustratest contents shared memory segment segment contains main job queue data structure high low priority queues also contains vital model image data along corresponding distance transforms go back updating shared memory convenient side effect constant size image distance transforms fact data portion structures changed way updating data structures shared memory simple call memset properly aligned position source destination pointers go back new semaphore rudimentary parallel implementation series semaphores synchronize access children master process shared memory segment new semaphore required however synchronize reentry children main work procedure new tracking task go back implementation issues first concern developing implementation climbing series learning curves included familiarization rivl shared memory unix semaphores biggest learning curve however understanding existing code im search determining changes would required change parallelization paradigm re using much existing code possible shared memory added significant hurdles due difficulty tracing pointers data structures remained unchanged initialization child processes explicitly left shared memory reason structures however pointed structures shared memory invariant maintained pointers shared memory constant structures could changed easiest way keep track structures shared memory turned putting order every time maintaining global information location structures shared memory relative start shared memory segment go back performance results tested implementation parallel rivl object tracker frame mpeg sequence sequence track motorcycle hurtles air courtesy terminator judgment day illustration sequence appears earlier paper tested implementation mhz processor sparc station running solaris version tested performance implementation using master process slave processes comparison also tested first implementation rivl parallel object tracker sequence processors control also tested sequential rivl object tracker sequence machine graph results appears following diagram unfortunately current performance results indicates implementation slower first implementation also slower sequential version however believe results truly indicative advantage implementation older one due fact ran time unable fully iron bugs inefficiencies implementation fine tune would reach full potential believe reflective soundness ideas however notable implementation scales better processors previous implementation implies implementation parallel object tracker significantly improve overall performance increase number slave processes go back extensions improvements number extensions improvements made improve overall performance extensibility tracking objects parallel rivl fine tune current implementation improvement goes without saying due time constraints project unable get kind overall performance results would liked need determine bottleneck killing performance done would expect see performance results greater original parallel object tracking implementation integrate parallel im search generic parallel rivl rivl developed goals make multimedia data processing easy program efficiently process multimedia data bearing goals mind parallelization rivl remain transparent tcl programmer sense programmer restricted generic set image operations e excluding im search able use every rivl operator processing every node proceed parallel work involves designing special operator detector generic rivl operators run parallel using fine grained generic parallel approach complex operators im search run parallel using scheme detector would find special nodes rivl graph handle accordingly port parallel im search atm fast ethernet using distributed shared memory extension current parallel implementation restricted shared memory machine however distributed shared memory software extension generates shared memory paradigm distributed architecture difficult port current implementation distributed environment using dsm software extension incorporate parallel im search cm rivl cm rivl version rivl developed cornell university allows rivl process sequences images feeding real time continuous media stream object tracking useful real time application makes interesting extension go back conclusions looking significant speedup new implementation rivl parallel object tracker moved n processors performance scaling n processors encouraging disappointed thus far overall performance results hoping time would fine tuned parallel rivl object tracker faster first attempt confident little work yield results looking intuitively makes sense implementation run faster previous implementation simple reason significantly reduced overhead involved setting running rivl multi processor environment go back references jonathan swartz brian c smith resolution independent video language proc third acm international conference multimedia san francisco ca november jonathan barber sugata mukhopadhyay fine grain parallel cm rivl step towards real time multimedia processing cornell university ny may j f canny computational approach edge detection ieee trans pattern analysis machine intelligence november dan huttenlocher g klanderman w j rucklidge comparing images using hausdorff distance ieee trans pattern analysis machine intelligence dan huttenlocher w j rucklidge multi resolution technique comparing images using hausdorff distance proceedings ieee computer vision pattern recognition conference w j rucklidge eugene ortenberg vijay menon distributed shared memory atm cornell university ny may sugata mukhopadhyay arun verma cmrivl programmable video gateway cornell university december
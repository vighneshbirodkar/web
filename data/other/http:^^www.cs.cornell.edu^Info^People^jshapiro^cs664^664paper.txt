mime version server cern date sunday dec gmt content type text html content length last modified friday may gmt parallel object recognition applications facial recognition parallel object recognition applications facial recognition matt androski chris paradis jody shapiro introduction project attempt parallelize computer vision object recognition algorithm given database edge detected object models previously unseen edge detected image algorithm attempts find models appear new image matching performed using approximation hausdorff fraction see figure simple example image search performed hierarchical scheme attempts minimize comparisons quickly eliminating regions image consideration figure previously unseen image containing model paper discuss pros cons different methods parallelization describe factors motivated design decisions describe parallel implementation using split c detail followed performance analysis also discuss suitability algorithm use facial recognition present results conclude discussion possible extensions parallel implementation facial recognition aspects approximation hausdorff fraction method uses approximation hausdorff fraction measure similarity two edge images size approximation computed using subspace representation two edge images distance fraction computed factored dilating one images distance application one images match model stored database region new image create subspace first convert model images column vector reading pixels column major order construct matrix vectors compute eigenvectors eigenvalues matrix select k largest eigenvalues create matrix corresponding eigenvectors matrix used project model images region new image subspace subspace representation two images k length vector primary step computing approximation hausdorff fraction dot product two k length vectors method described detail subspace representations database models precomputed stored along matrices data needed perform projection operation regions image searching need projected subspace run time projection operation computationally expensive therefore search algorithm parallelization method attempt minimize number projections performed note approximation accurate within true hausdorff fraction final decisions relative quality match made using true bi directional hausdorff fraction search algorithm search algorithm presented attempts minimize number projections comparisons performing coarse fine examination new image new image subdivided cells cell represents set translations model respect image model translated center cell compared region image dilated radius cell see figure amounts rough comparison model every possible translation cell resulting fraction less threshold set translations represented cell ruled match model resulting fraction threshold algorithm subdivides cell four quadrants considers repeated model ruled algorithm recursed point cell one translation see figure model cannot ruled approximation lowest level true bi directional hausdorff fraction calculated model still cannot ruled marked possible match fraction position stored later consideration figure image divided x cells model translation shown figure x cell searched depth first coarse fine strategy thus search depth first cell image independent entity projections regions new image computed cell level efficiency models passed test higher level compared projection list survivors passed next lower level search algorithm described detail parallelization issues first major task parallelizing object recognition algorithm deciding distribute processing amongst processors one option distribute search cells across processors thus processor would assigned group cells would search cells models database method attractive features cells independent entities image projections associated projections could computed used locally models communication processors would necessary however method requires processor access entire database models test database contained view models total models database size complete set models processor unreasonable however real application would require much larger database would preclude use method second option distribute models across processors thus processor would subset models database would search every cell image set models method much tolerant large database first introduces significant problems processor searching cells image every processor need image projections calculated image projections expensive processor compute projections locally unacceptable instead necessary processors store projections global data structure calculated processors access introduces significant network traffic parallel version however since method handle large database much effectively became choice implementation implementation chosen faced two primary issues parallelization one issue efficiently compute share image projections prevent processors needing access projections simultaneously stagger starting points processor across image searching ideal case processors move cell cell lock step without conflicts two processors happen need projection simultaneously projection yet calculated simple locking mechanism ensures one calculation waits given processor needs projection first checks see projection calculated gets projection uses calculated locks projection calculates stores global structure fails lock projection another processor must computing waits computation completes second issue load balance issue appeared deceptively simple since large quantity models could easily distributed across many processors problem simple solution arose organization database views models stored sequentially database given processor would assigned views objects one objects appeared image processor would many close matches processors would recurse deeply image created distinct load imbalance solved problem spreading views object across processors real application would sensible store views object order solve problem change place achieved much acceptable load balance figure shows load balance algorithm correction important note however impossible predict models cause deepest searches always certain amount load imbalance figure load balancing performance split c implementation complete measured performance sp massively parallel processor also compiled sequential version sp measured performance graph figure shows performance results terms speedup sequential version figure speedup vs number processors graph clearly shows parallel implementation achieves less ideal performance ideal performance would speedup n test n processors results good hoped attempted identify source overhead limiting performance separately measured time spent phase search breakdown time different numbers processors shown figure figure breakdown processing time single processor graph shows parallel version run one processor performs nearly well sequential version however processors added see time spent fetching projections global structure significant source overhead number processors used increases fewer projections calculated locally global accesses required graphs show overhead associated fetching projections increases processors solve problem would like fetch projections using split phase access calculations waiting data arrive however nature algorithm prevents us knowing advance projections need thus time know need projection calculations perform waiting data experiments facial recognition parallel implementation complete began investigate usefulness method facial recognition goal see algorithm could successfully find faces scene using approximation hausdorff fraction one test method considered inserting face models database directly scenes seeing could match works well artificial instead use images database people appear database see effectively find faces much representative real world situation started construction database set images set consisted poses different people wanted exclude poses database could search scenes elected save odd numbered poses matching construct database even numbered poses resulting database shown figure used database construct subspace needed supporting data described next step create set images search didn access people appear database decided create synthetic images inserting edge images ones kept database images contained faces roughly size attempted select images contained significant number faces additional clutter introduce possibility false matches included several synthetic test images results searches set images includes original grayscale corresponding edge image pair images following consists synthetic image created inserting face wish search image best match overlayed red notation x y associated inserted face indicates inserted pose y person x instances search fails identify correct face correct face shown blue result search shown red coordinates match column followed row origin top left figure face database original image edge detected version person inserted found person person inserted found person person inserted found person original image edge detected version person blue inserted found person red person blue inserted found person red person inserted found person original image edge detected version person inserted found person person inserted found person original image edge detected version person inserted found person person blue inserted found person red facial recognition results results experiments facial recognition mixed pleased often algorithm successfully selected correct person match face scene however algorithm sometimes fail incorrectly selects another face rare cases something even face however key result tests subtle examined possible matches survived hausdorff approximation based search found correct result nearly always present test set large enough suggest statistical conclusions believe search algorithm effective quickly eliminating non matches without eliminating good matches final decision element database best match made true hausdorff approximation believe algorithm fails thus may possible use approximate hausdorff method quickly search image use robust face matching algorithm pick best match survivors method developed turk et al might good choice application conclusions established searching scene given set models conducted efficiently using approximation hausdorff fraction first part project shown algorithm effectively parallelized thus enough processors disposal quickly search new scene models database determined algorithm successfully applied problem facial recognition given database faces scene possible use algorithm search image people appear database algorithm potential applications means identifying unknown individuals could used law enforcement agencies searching criminal records companies could use verify identity employees part security general problems face detection could addressed variant algorithm searches face like structures scene work could also extended search given face sequence images future work improvements primary limiting factor parallel algorithm time spent fetching projections global structure already stated predicting need given projection would allow us perform split phase access avoid wasting time waiting network supply data future revision implementation include means projection prediction simplistic approach would fetch projections might needed danger approach scheme would increase network traffic congestion significantly proper approach would employ something akin branch prediction scheme high accuracy another possible approach improving algorithm might use breadth first search rather depth first one would allow accurately predict projections would need however would also require storage list surviving models cell level search proceeds memory requirements lists would significant perhaps prohibitive yet another solution would use first method parallelization described would distribute cells across processors processor could compute projection cells needed store problem storing models could solved subdividing database model sets processor would consider one set time nearing completion set processor could begin reading next set file would keep memory requirements minimum however demands file system might become limiting factor algorithm implementation see three main areas future work respect facial recognition larger set test images could used effort produce real statistics recognition performance however statistics still approximations facial recognition inherently non quantifiable real test images opposed synthetically generated test images could used would require people database naturally appear test images likely new face database would need created would also interesting see search algorithm performs changing lighting conditions true hausdorff fraction computed eliminate matches necessarily best measure use facial recognition edge detected images faces necessarily good basis final matching perhaps better method would use greyscale based matching scheme method used might good candidate certainly edge detection based matching appears useful quickly efficiently narrowing search references huttenlocker r h lilien c olson object recognition using subspace methods hiroshi murase shree k nayar visual learning recognition d objects appearance international journal computer vision matthew turk alex pentland eigenfaces recognition journal cognitive neuroscience vol number david e culler et al parallel programming split c proceedings supercomputing chi chao chang grzegorz czajkowski thorsten von eicken design performance active messages ibm sp olivetti research laboratory database faces carnegie mellon university test images face detection source code
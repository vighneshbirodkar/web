mime version server cern date sunday dec gmt content type text html content length last modified monday may gmt parallel raytracing cc parallel raytracing cc cs final project spring vineet ahuja amith yamasani abstract project parallelisation public domain raytracer implemented cc compositional c sp raytracing easily parallelised screen split several areas area given one processor problem arises antialiasing needs performed reduce aliasing effects due finite sampling due boundaries processors need kept minimum one also needs worry balancing load well processors depending complexity scene transferring results back one processor write disk also becomes issue attempted tackle problems come efficient solution possible given constraints language size problem set introduction cc compositional c language supports structured parallel programming developed caltech computational biology group provides structured parallelism form par blocks parfor loops unstructured parallelism form spawn statement functions preceeded keyword atomic used implement mutual exclusion functions work shared data sync variables used synchronization global keyword used modify pointers refer local remote memory sync variables work suspending thread tries read variable till variable written another thread processor objects objects control computation processor defined regular manner except global keyword used class definition data transfer functions defined calling functions lie another processor object data like arrays user defined data structures copied sent processor raytracing picked public domain implementation raytracer called raylab worked parallelising raytracing method rendering graphics scene considers rays entering viewers eye method traces path rays eye scene calculates intensity color ray depending ray path reflections calculating ray value independent calculation rays parallelisation trivial difficulty parallelisation arises need perform antialiasing antialiasing used reduce jaggies ouptut image caused finite sampling rate screen e finite resolution done pixel considering immediate pixels east south south east strategies parallelisation strategy blocked row distribution easiest method divide screen n strips n number processors allow processor ray trace strip problem method load balancing example objects scene lie strip n nth procesor would work leaving first n processors idle completed strips strategy column row cyclic distribution another static division method one divides screen small squares n x n pixels n x n number processors pixels square goes different processor basically column row cyclic division see figure problem method anti aliasing longer straight forward current pixel neighbours different processors performance becomes issue processor go across network connecting processors anti alias pixel strategy hungry puppies method works dividing screen strips m lines processor designated master rest nodes slaves slave node requests work master goes back ray trace strip completion returns quantized ray traced strip gets work master quantization mean converting values rgb value pixel float char throw display goes till strips ray traced slave hungry puppy runs master work master node writes entire raytraced scene disk another problem antialiasing processor last row strip needs next row another processor antialias two different implementations handle problem one compute next row processor well computation twice one processors actually owns line send unquantized last first rows strip addition quantized values last row strip master node antialias last rows strips therefore avoiding redundant computation time version bug performance results discussed next section respect first implementaion obvious problem method scalablity since slaves sending much data master lot contention resources master obviously limits number processors thrown problem implementation details define types processor objects see section dispatcher tracer dispatcher essentially master processor dishes work tracer actual raytracing strip node contains dispatcher tracer since would waste processor dedicate sending strip numbers tracer disk writes timed disk writes ray tracing serial version found raytracing pixel times expensive writing disk found problem cc data sent another processor means data transfer functions unnecessary copying data packaged data transfer function avoided problem defining copy constructors actually allocate memory data referred pointers make new object point data old object define destructor releases memory way could think avoiding extra copies sync variables used dispatcher waiting tracers complete work cycles wasted waiting dummy loop dispatcher main loop suspended till sync variable set function dispatcher decides strips traced function dishes work dispatcher called needlines atomic function since increment counter giving next strip function called simultaneously tracers almost simultaneously value counter might make sense copies needlines access counter together performance speedup graph shows speedup vs number processors speedup defined ratio time taken run serial implementation time taken run parallel version speedup almost linear doesnt slope bottleneck created processor also needs act dispatcher thus tracer processor isn efficient tracers processors communication vs computation time series graphs shown show breakup time taken code run computation time communication time seen graphs performance program maximum granularity lines per chunk lower granularity communication overhead becomes high higher granularity efficiency goes due load imbalance processors get work others get less work stay idle longer time shown true load balancing graph load balancing graph shows ratio maximum work done processor minimum work done processor showing effectivley load balancing policy low granularity processor ends taking much longer work interrupted often dispatcher invoked tracers slightly higher granularities load much better balanced high granularity load imbalance due processors getting intensive work others experiences conclusions cc found cc overall effective language work allowed us think parallelism structured manner however also found compiler worked inefficient code generation fairly compare parallel implementation original serial c version recompile serial version cc compiler otherwise output code c compiler ray tracing code therfore computation intensive part program faster cc code another problem data transfer functions mentioned earlier raytracing feel best way handle antialiasing using shared memory multiprocessors processors readily access neighbouring rows handled processors also since processor needs first row next block antialias last row almost certain neighbouring processor would completed raytracing row processor therefore immediately use data statement made assumption processors carry work load outside raytracing
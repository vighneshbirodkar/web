date tue nov gmt server ncsa content type text html last modified tue sep gmt content length debugging using gdb debugging using gdb http www cs wisc edu cs gdb html authors charles fischer tom reps james larus look example programs accompany document contents introduction gdb debugging using gdb program crashed using gdb program produces incorrect output additional gdb commands summary gdb commands introduction ve written program correctly compiles must thoroughly test newly written programs contain errors bugs must discovered corrected process debugging testing program encounter two forms bugs program fails terminate expected crashes instead program doesn crash produces unexpected incorrect output gdb debugger save large amounts time frustration helping find types bugs quickly easily program crashes run program control gdb get chance inspect state program moment crashed program doesn crash instead produces unexpected incorrect output run program control gdb find errors cause incorrect output sometimes program produces incorrect output wrong rather subtle ways example numeric result may differ slightly correct answer sometimes program may fail rarely usually giving correct output job programmer thoroughly test program releasing users may involve creating suite standard tests program must handle flawlessly sure always recognize correct output may need write additional code verifies program really produces correct output example computing square roots might square root compare original value complex calculations sometimes good idea code second independent solution problem test code compare results two solutions produce produce answers tests usually reasonable assume answers correct gdb debugging gdb programming tool available unix systems debugging c c programs plan use gdb debug programs must compile source files using g option debug option produces tables debugger needs moreover x windows version gdb called xxgdb window interface may find lot easier pleasent use however program difficult describe words document explains plain version gdb commands also work xxgdb click button instead typing however let first note fastest best way use debugger use many cases careful examination program output gives great deal information went wrong example program crashed must portion program last output produced first expected output wasn produced however note many systems buffer output sometimes happens program may produce part output line never printed program crashed cout flush forces buffered output immediately printed even program doesn crash careful examination program output reveal patterns correct incorrect values may well indicate likely errors get incorrect outputs panic calmly look produced try reason went wrong use editor examine parts program likely responsible errors still explain went wrong may time use gdb xxgdb gather information using gdb program crashed program crashes encounters error severe execution impossible unix operating system prints message saying caused program terminate kills program termination message rarely specific helpful common messages segmentation fault bus error usually indicate invalid array access pointer reference occurred section ll show gdb used discover reason program crashed illustrate using gdb crash ll use following simple c program bug c tries allocate initialize print array strings line numbers reference purposes include iostream h allocate initialize print array strings void init char str int str x str int main int j char strs strs new char init strs cout strs j endl return compile execute bug c program crashes printing output get following message segmentation fault core dumped idea went wrong time use gdb need re run program control gdb gdb bug gdb free software welcome distribute copies certain conditions type show copying see conditions absolutely warranty gdb type show warranty details gdb sparc sun sunos copyright free software foundation inc gdb run starting program afs cs wisc edu p course cs reps private gdb bug program received signal sigsegv segmentation fault x init str x address x bounds bug c str x gdb gdb tells us execution terminated function init line file bug c also shows us source line number extreme left line number line gdb prompt gdb waiting us give command good start command tell us context crash occurred gdb x init str x address x bounds bug c x main bug c gdb shows call stack sequence function calls progress point termination top list recent call bottom original call hexadecimal numbers like x addresses ll normally ignore execution terminated init line bug c called main line bug c point ll want look part program around lines file bug c gdb command list files named list gdb list int str x sometimes want create new window look file question using favorite editor ll probably want correct bugs find looking line listing bug c shown see assignment character pointed variable str let print values str str see seem reasonable command print value print abbreviated p gdb p str x address x bounds gdb p str cannot access memory address x pointer variable str value x address gdb reported us hexadecimal format looks suspicious pointers usually large values fact look value str confirms suspicion gdb tells us cannot access memory address symbols left equal sign starting internal variables gdb stores values printed know execution terminated tried assign value bad pointer problem figure str assigned bad address look value see far loop progressed gdb p value loop started init probably passed bad pointer caller find information caller must tell gdb focus another point call stack caller init command take us one call takes us back call stack gdb x main bug c init strs ve moved call stack current procedure main current position code line function main gdb list strs new char init strs look values variables visible main particular let look values strs strs gdb p gdb p strs x gdb p strs cannot access memory address x value reasonable value strs small address find cannot accessed memory illegal pointer value strs caused crash know strs invalid let also look values strs ask see value entire array gdb p strs x x xxxxxxxxxx x xxxxxxxxxx x xxxxxxxxxx gdb shows us address array possible value string address points realize last element shown strs value shown strs e x moreover last element strs seems properly initialized gives us final clue c arrays based valid subscripts strs range crazy value strs come use subscript big actually access variables declared array looking program variable currently value know convert hexadecimal decimal know x fact summarizing able find using gdb following program incorrectly went beyond end strs tried use value string pointer exit gdb using command quit change example program use subscripts range program work correctly point copy program bug c compile g remember use g option run executable get segmentation fault enter gdb re run program try print commands ll discuss commands shortly wish use gdb help command find categories commands available gdb help list classes commands running running program stack examining stack data examining data breakpoints making program stop certain points files specifying examining files status status inquiries support support facilities user defined user defined commands aliases aliases commands obscure obscure features internals maintenance commands type help followed class name list commands class type help followed command name full documentation command name abbreviations allowed unambiguous also make help request find class commands example gdb help breakpoints making program stop certain points list commands awatch set watchpoint expression rwatch set read watchpoint expression watch set watchpoint expression catch set breakpoints catch exceptions raised break set breakpoint specified line function clear clear breakpoint specified line function delete delete breakpoints auto display expressions disable disable breakpoints enable enable breakpoints thbreak set temporary hardware assisted breakpoint hbreak set hardware assisted breakpoint tbreak set temporary breakpoint condition specify breakpoint number n break cond true commands set commands executed breakpoint hit ignore set ignore count breakpoint number n count type help followed command name full documentation command name abbreviations allowed unambiguous finally make help request find individual commands example gdb help break set breakpoint specified line function argument may line number function name address line number specified break start code line function specified break start code function address specified break exact address arg uses current execution address selected stack frame useful breaking return stack frame multiple breakpoints one place permitted useful conditional help breakpoints info commands dealing breakpoints using gdb program produces incorrect output program crashes least starting point begin debugging process look line executed crash occurred try determine program misbehaved however program terminates cleanly produces incorrect unexpected output things harder one way debug program insert print statements selected points program recompile program rerun hopefully additional data provide clues went wrong alternative usually efficient way debug use gdb allows supervise control execution program interactively things gdb permits set clear breakpoints specific functions line numbers breakpoint stops execution particular point allowing issue additional debugger commands look value variables single step program running one source line time resume execution next breakpoint encountered end program reached illustrate debug misbehaving program consider bug c include iostream h count number adjacent array elements equal int main int int cnt many adjacent elems equal int cnt cout number adjacent values equal cnt endl return program designed step array counting pairs adjacent elements equal compile run get following g g wall o bug bug c bug number adjacent values equal program terminates cleanly e run time error reported look values array given line see answer computed plainly wrong could explicitly add print statements recompile program using gdb easier far flexible every print statement add must eventually removed disabled gdb bug gdb free software welcome distribute copies certain conditions type show copying see conditions absolutely warranty gdb type show warranty details gdb sparc sun sunos copyright free software foundation inc gdb run starting program afs cs wisc edu p course cs reps private gdb bug number adjacent values equal program exited normally gdb get output normal termination remark saw bug gdb command run lets us start execution program within gdb program arguments included run command example program usually called testprog f file would run within gdb issuing command run f file standard input entered keyboard standard output appears screen possibly intermixed output gdb commands end remark get gdb stop running program look values example use break command abbreviated b give either name function line number time function line number reached gdb stops waits additional commands command print value variable command resume execution execution resume next breakpoint encountered end program reached enter continue execute one line program known single stepping enter next abbreviated n step abbreviated difference next step next takes next source line current function whereas step takes next source line may another function current line calls function hitting return key reexecutes recent command thus entering one n command followed number returns allows step program one line time long programs would tedious need start stepping beginning simple program set breakpoint function main step first lines program give us sense program executing gdb b main breakpoint x f file bug c line gdb run starting program afs cs wisc edu p course cs reps private gdb bug breakpoint main bug c int gdb n int cnt many adjacent elems equal gdb numbers extreme left line numbers looks like program incrementing variable cnt iteration let print value gdb p gdb p gdb p values look ok breakpoint line gdb shows next line executed execute ll let execute ll look values gdb n cnt gdb p gdb p gdb p intention true branch increments variable cnt execute equals however result executing condition changed value clue equality operator c operator assignment operator understand happening time test performed assigning value treating value boolean value test since none values treated true way correct program change line additional gdb commands single stepping large program tedious another strategy set breakpoints key statements modify critical data points look values single step bit see program going example program bug c line would good place set breakpoint since variable cnt incremented case would seen cnt incremented iteration looking values would soon showed us unintentional assignment condition statement breakpoint cleared clear command naming line function breakpoint cleared example obvious line place value cnt changed hence good place put breakpoint large programs sometimes obvious given variable set command watch expr expr c expression allows ask gdb stop whenever expr changes value thus command watch cnt would instructed gdb stop whenever cnt changed value execution would stopped statement change gdb would showed us old new values watch commands slow gdb lot use judiciously note watch variable v must within scope contains v set breakpoint start main function set watch involving variables function might used watch program bug gdb bug gdb b main breakpoint x f file bug c line gdb run starting program afs cs wisc edu p course cs reps private gdb bug breakpoint main bug c int gdb watch cnt watchpoint cnt gdb continue continuing watchpoint cnt old value new value main bug c another useful gdb command commands allows give collection gdb commands executed gdb time certain breakpoint encountered especially useful trying keep eye number variables tell gdb print values breakpoint rather typing print commands hand every time gdb stops breakpoint instance example debugging program bug could values cnt printed time breakpoint line encountered gdb bug gdb b main breakpoint x f file bug c line gdb run starting program afs cs wisc edu p course cs reps private gdb bug breakpoint main bug c int gdb b breakpoint x file bug c line gdb commands type commands breakpoint hit one per line end line saying end p cnt p p end gdb continue continuing breakpoint main bug c cnt gdb continue continuing breakpoint main bug c cnt another feature gdb cuts much type command editing feature scroll past commands using arrow arrow keys ve found similar command one want issue edit text command using left arrow right arrow backspace etc point copy program bug c compile g remember g option enter gdb experiment breakpoints single stepping watches commands remember forget details command say help command gdb give information command summary gdb commands gdb many commands discussed document using gdb details available document long almost pages detailed fortunately commands ve discussed make effective use gdb let review commands ve seen effect command effect quit terminate gdb show call stack execution halted p print value variable expression refocus gdb one function call stack refocus gdb one function call stack help get help command run start execution program b set breakpoint line function clear clear breakpoint line function commands set commands executed breakpoint hit execute one line possibly subroutine n execute next line current function continue continue execution next breakpoint watch watch change expression slow list list source lines function commands discuss useful command effect info b show breakpoints set delete breakpoint remove single breakpoint use info b find breakpoint numbers cond condition convert breakpoint conditional breakpoint breakpoint number cond c expression example cond x set var expr set given variable value given expression execute program reaches source line greater specified line function execution also stop upon exit current stack frame learning new tool like gdb tedious however ve mastered gdb greatly ease debugging ll soon wonder ever got without
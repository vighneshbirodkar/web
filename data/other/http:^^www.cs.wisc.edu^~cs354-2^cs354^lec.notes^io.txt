date tue nov gmt server ncsa content type text html last modified wed aug gmt content length lecture notes chapter o chapter o o computers aren useful unless put data get results input data computer output data computer computer model cpu memory o examples input devices keyboard mouse network disk examples output devices printer terminal display network simulator o devices keyboard input display output issues must solved programmer interface simulator get getc put putc puts actually os implemented procedures os program interfaces programmer application user actual hardware us snakes unix protection issues real system could one terminal terminal keyboard display together one user able display characters another display lock another keyboard send file infinite length printer effectively shutting others practice os job resource management allocating portions processor examples resources cpu o devices physical issues computer today complete instruction rate nsec mhz mips unfortunately typical o devices much slower often requiring milliseconds deal single character approx million times slower situation dubbed access gap disk real live phisical device vocabulary form picture disk ch p platter sort like phonograph record data stored surface platter platters tied together rotate around spindle fixed speed surface one read write heads platters broken tracks single track one many concentric circles platter corresponding tracks surfaces taken together form cylinder track broken sectors read write sector given sector position cylinder looked table calculated disk address disk spinning read write head moving correct cylinder track takes long time relative stuff physical movement acceleration etc comes play seek time read write head correct cylinder bound time wait correct sector head rotational latency even correct sector still takes time data read written read write time time read sector seek time rotate time read time nitty gritty issue os accomplish o requests possibilities special o instructions input need know device much data data go output need know device much data data currently cpu know instruction completed need wait happens device encounters error halt computer solution choice overload memory locations use communication channels example address x real memory xffff xffff data keyboard keyboard data xffff data display display data reading loading location xffff data requested keyboard writing storing location xffff data sent display syscall code os must essence lw keyboard data getc syscall return syscall sw display data putc syscall return syscall method o called memory mapped o problems memory mapped o currently given getc presumably returns character typed happens user type character types wrong keyboard goes get drink water happens data user types characters getc called computer know character typed putc puts computer know device ready print second character printer jams printers terminals slow needed way convey information status o devices status information used coordinate synchronize useage devices address x real memory xffff xffff data keyboard keyboard data xffff c status keyboard keyboard status xffff data display display data xffff status display display status assume msb used tell status device msb means device ready msb means device busy note check device ready busy looking see status word negative comp keyboard means character typed means character available display means new character may sent means device still disposing previous character syscall code os must like getc loop lw keyboard status getc syscall bgez getc loop lw keyboard data return syscall putc loop lw display status putc syscall bgez putc loop sw display data return syscall scheme known busy waiting spin waiting little loop called spin wait loop something well explained level status bits get set cleared spin wait loop reads status word change device controller sets clears bit implied fuction device sets bit becomes ready work another character load keyboard data also clears msb keyboard status store display data also clears msb display status problems programmed o approach much time wasted spin waiting takes instructions program instruction takes ns execute takes nsec nsec usec execute code device takes msec usec deal one character percent time spent waiting time waiting us total time us usec d like solution spent less time nothing somehow second key pressed program getc first key pressed lost one character worth storage problem actually catch getc code run often enough characters lost executing code spin waits character pressed system could nothing getc calls problems solved use queues buffers check device ready separated sending receiving characters code text pages putnextchar print character one queue device ready printstring put character queue return getnextchar get character one available put queue getstring get character queue available return difficulties caused situation someone user os must call getnextchar regularly often lose characters happens queue become full characters lost someone user os must call putnextchar regularly empty queue
date tue nov gmt server ncsa content type text html last modified wed aug gmt content length lecture notes chapter performance features chapter performance features architectural features used enhance performance loosely following chapter better computer best computer factors involved generally cost performance cost factors cost hardware design cost software design os applications cost manufacture cost end purchaser performance factors programs run frequently run big programs many users sophisticated users o devices necessary chapter discusses ways increasing performance two ways make computers go faster wait year implement faster better newer technology transistors fit single chip pins placed around ic process used electronic devices transistors switch faster new innovative architectures architectural features memory hierarchies known current technologies time access data memory order magnitude greater cpu operation example bit complement addition takes time unit load bit word takes time units since every instruction takes least one memory access instruction fetch performance computer dominated memory access time try help difficulty load store architectures instructions take operands memory also try fixed size small size instructions really want fast memory speed cpu large capacity mbytes low cost mutually incompatible faster memory expensive becomes larger amount memory slower becomes compromise take advantage fact fact looking many real programs memory accesses random tend exhibit locality locality nearby kinds locality time temporal locality data referenced recently likely referenced soon example instructions loop loop likely executed therefore instruction gets referenced repeatedly short period time example top stack repeatedly referenced within program locality space spacial locality data referenced recently data nearby memory likely referenced soon example array access elements array neighbors memory likely referenced one example instruction streams instructions located memory next model program execution says unless pc explicitly changed like branch jump instruction sequential instructions fetched executed use tendencies advantage keeping likely referenced soon data faster memory main memory faster memory called cache cpu cache memory located close cpu contains copies parts memory standard way accessing memory system cache programmer doesn see know instruction fetch load store goes cache data cache hit data handed cpu memory access completed data cache miss instruction fetch load store sent main memory average time memory access cache access time misses memory access time average mean access time change program depends program reference pattern pattern interracts cache parameters cache managed hardware keep recently accessed block exploits temporal locality break memory aligned blocks lines e g bytes exploits spatial locality transfer data cache blocks put block block frame state e g valid address tag data simple cache diagram inf f f f speedup says concentrate common case